// THIS IS AUTOGENERATED TO ASSIST WITH AI CONTEXT. DO NOT EDIT.

// ===== File: src/ast.rs =====

use crate::types::Type;

#[derive(Debug, Clone, PartialEq)]
pub struct Program {
    pub statements: Vec<Statement>,
}

impl Default for Program {
    fn default() -> Self {
        Self {
            statements: Default::default(),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct FunctionDecl {
    pub name: String,
    pub params: Vec<Parameter>,
    pub return_type: Option<Type>,
    pub body: Block,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Parameter {
    pub name: String,
    pub param_type: Type,
}

#[derive(Debug, Clone, PartialEq)]
pub struct ClassDecl {
    pub name: String,
    pub body: Vec<ClassItem>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ClassItem {
    Field { name: String, field_type: String },
    Method(FunctionDecl),
}

#[derive(Debug, Clone, PartialEq)]
pub struct Block {
    pub statements: Vec<Statement>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Statement {
    VarDeclaration {
        name: String,
        type_annotation: Type,
        initializer: Expression,
    },
    Assignment {
        name: String,
        value: Expression,
    },
    ExpressionStatement(Expression),
}

#[derive(Debug, Clone, PartialEq, Copy)]
pub enum UnaryOperator {
    Negate,
    Not,
}

#[derive(Debug, Clone, PartialEq, Copy)]
pub enum BinaryOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Equal,
    NotEqual,
    LogicalAnd,
    LogicalOr,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Expression {
    Number(f64),
    Bool(bool),
    String(String),
    Identifier(String),
    Unary {
        operator: UnaryOperator,
        operand: Box<Expression>,
    },
    Binary {
        left: Box<Expression>,
        operator: BinaryOperator,
        right: Box<Expression>,
    },
    Nil,
}


// ===== End of src/ast.rs =====

// ===== File: src/error_handling.rs =====

#[derive(Debug, Clone, Copy)]
pub struct Position {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
}

impl Default for Position {
    fn default() -> Self {
        Self {
            line: 1,
            column: 0,
            offset: 0,
        }
    }
}

impl Position {
    pub fn new(line: usize, column: usize, offset: usize) -> Self {
        Self {
            line,
            column,
            offset,
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub struct Span {
    pub start: Position,
    pub end: Option<Position>,
}

impl Default for Span {
    fn default() -> Self {
        Self {
            start: Default::default(),
            end: None,
        }
    }
}

impl Span {
    pub fn new(start: Position, end: Option<Position>) -> Self {
        Self { start, end }
    }
}


// ===== End of src/error_handling.rs =====

// ===== File: src/heap.rs =====

use std::{cell::RefCell, rc::Rc};

use crate::object::{HeapObject, Object};

/// Heap is the memory heap for allocating and deallocating memory
/// that is tracked by the runtime.
#[derive(Debug, Clone)]
pub struct Heap {
    /// An intrusive linked list tracks all of the
    /// allocated objects on the heap.
    objects: Option<Rc<RefCell<HeapObject>>>,
    /// The number of bytes allocated since the last GC.
    allocated_bytes_since_last_gc: usize,
    /// The number of bytes, that when exceeded, triggers a garbage collection cycle.
    gc_threshold_bytes: usize,
}

impl Heap {
    /// Create a new heap.
    ///
    /// # Parameters
    /// * `initial_threshold` - The size in bytes until the first GC.
    pub fn new(initial_threshold: usize) -> Self {
        Self {
            objects: None,
            allocated_bytes_since_last_gc: 0,
            gc_threshold_bytes: initial_threshold,
        }
    }

    /// Create a new heap-managed allocation.
    ///
    /// # Params:
    /// * `object` - The object to place on the heap.
    ///
    /// # Returns:
    /// * The allocated object, now tracked by the heap.
    pub fn allocate(&mut self, object: Object) -> Rc<RefCell<HeapObject>> {
        let heap_obj = HeapObject::new(object, self.objects.take());
        let new_alloc = Rc::new(RefCell::new(heap_obj));
        self.objects = Some(new_alloc.clone());

        self.allocated_bytes_since_last_gc += new_alloc.borrow().size();

        new_alloc
    }

    /// Determine if garbage collection is needed.
    ///
    /// # Returns:
    /// * True when the allocations have exceeded the threshold, otherwise false.
    pub fn needs_collection(&self) -> bool {
        self.allocated_bytes_since_last_gc >= self.gc_threshold_bytes
    }

    /// Lets the heap know that now is a safe time to run a garbage collection.
    ///
    /// # Parameters
    /// * `roots` - A slice of `Rc<RefCell<HeapObject>>` representing all currently
    ///   reachable objects from the VM (e.g., stack values, globals, and other
    ///   root references). The GC will start marking from these objects to
    ///   determine which objects are still alive.
    pub fn collect_garbage(&mut self, roots: &[Rc<RefCell<HeapObject>>]) {
        self.mark(roots);
        self.sweep();
    }

    /// Mark all of the objects that are reachable from the provided roots
    /// to prepare for a garbage collection. Any marked items are spared from collection.
    ///
    /// # Params
    /// * `roots` - A slice of `Rc<RefCell<HeapObject>>` representing all currently
    ///   reachable objects from the VM (e.g., stack values, globals, and other
    ///   root references). The GC will start marking from these objects to
    ///   determine which objects are still alive.
    fn mark(&mut self, roots: &[Rc<RefCell<HeapObject>>]) {
        let mut gray_stack: Vec<Rc<RefCell<HeapObject>>> = roots.to_vec();

        while let Some(obj_rc) = gray_stack.pop() {
            let mut obj = obj_rc.borrow_mut();
            if obj.marked {
                continue;
            }

            obj.marked = true;

            // add child references to gray stack
            for child in obj.children() {
                gray_stack.push(child.clone());
            }
        }
    }

    /// Remove all unmarked objects from the list and relink the list.
    /// When unmarked objects are removed from the list, if no other references
    /// exist to that object, the object will be freed.
    pub fn sweep(&mut self) {
        let mut new_head: Option<Rc<RefCell<HeapObject>>> = None;
        let mut last: Option<Rc<RefCell<HeapObject>>> = None;

        let mut current = self.objects.take();
        let mut reclaimed_bytes = 0;

        while let Some(obj_rc) = current {
            let mut obj = obj_rc.borrow_mut();
            let next = obj.next.take();

            if obj.marked {
                obj.marked = false;

                if let Some(last_rc) = &last {
                    last_rc.borrow_mut().next = Some(obj_rc.clone());
                } else {
                    new_head = Some(obj_rc.clone());
                }

                last = Some(obj_rc.clone());
            } else {
                // If the object isn't marked, we let it drop.
                reclaimed_bytes += obj.size();
            }

            current = next;
        }

        self.objects = new_head;

        // Reset allocation counter
        let allocated_since_last_gc = self.allocated_bytes_since_last_gc;
        self.allocated_bytes_since_last_gc = 0;

        // Adaptive threshold: increase if little reclaimed, decrease if lots freed
        let freed_fraction = reclaimed_bytes as f64 / (allocated_since_last_gc.max(1) as f64);
        if freed_fraction < 0.1 {
            self.gc_threshold_bytes = (self.gc_threshold_bytes as f64 * 1.5) as usize;
        } else {
            // Avoid shrinking too much
            const MIN_THRESHOLD: usize = 1024;
            self.gc_threshold_bytes = std::cmp::max(
                MIN_THRESHOLD,
                (self.gc_threshold_bytes as f64 * 0.8) as usize,
            );
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn unreferenced_objects_are_collected() {
        let mut heap = Heap::new(1024);

        // Allocate three objects, none of which are roots
        heap.allocate(Object::String("one".into()));
        heap.allocate(Object::String("two".into()));
        heap.allocate(Object::String("three".into()));

        // Before GC, the heap has 3 objects
        assert!(heap.objects.is_some());

        // Run GC with no roots
        heap.collect_garbage(&[]);

        // After GC, the list should be empty
        assert!(heap.objects.is_none());
    }

    #[test]
    fn referenced_objects_are_preserved() {
        let mut heap = Heap::new(1024);

        // Allocate some objects
        let obj1 = heap.allocate(Object::String("one".into()));
        let _ = heap.allocate(Object::String("two".into()));

        // Only obj1 is a root
        let roots = vec![obj1.clone()];

        // Run GC
        heap.collect_garbage(&roots);

        // obj1 should still be alive
        assert!(heap.objects.is_some());
        assert!(
            heap.objects.as_ref().unwrap().borrow().marked == false
                || heap.objects.as_ref().unwrap().borrow().object == Object::String("one".into())
        );

        // obj2 should be collected
        // Note: since we don't have direct access to obj2, we just check count
        // We could traverse the list and count elements if needed
        let mut count = 0;
        let mut current = heap.objects.clone();
        while let Some(rc) = current {
            count += 1;
            current = rc.borrow().next.clone();
        }
        assert_eq!(count, 1);
    }
}


// ===== End of src/heap.rs =====

// ===== File: src/keywords.rs =====

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Keyword {
    If,
    Else,
    Class,
    Return,
    Continue,
    Break,
    Let,
    Nil,
    While,
    For,
    Function,
    This,
    Super,
    True,
    False,
    And,
    Or,
}

impl TryFrom<&str> for Keyword {
    type Error = String;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "if" => Ok(Keyword::If),
            "else" => Ok(Keyword::Else),
            "class" => Ok(Keyword::Class),
            "return" => Ok(Keyword::Return),
            "continue" => Ok(Keyword::Continue),
            "break" => Ok(Keyword::Break),
            "let" => Ok(Keyword::Let),
            "nil" => Ok(Keyword::Nil),
            "while" => Ok(Keyword::While),
            "for" => Ok(Keyword::For),
            "fn" => Ok(Keyword::Function),
            "this" => Ok(Keyword::This),
            "super" => Ok(Keyword::Super),
            "true" => Ok(Keyword::True),
            "false" => Ok(Keyword::False),
            "and" => Ok(Keyword::And),
            "or" => Ok(Keyword::Or),
            _ => Err(format!("{value} is not a keyword")),
        }
    }
}


// ===== End of src/keywords.rs =====

// ===== File: src/lexer.rs =====

use crate::{
    error_handling::{Position, Span},
    keywords::Keyword,
    tokens::{Delimiter, Operator, Special, Token, TokenKind},
};

#[derive(Debug, Clone)]
pub struct Lexer {
    pub source: Vec<char>,
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub line_offset: usize,
}

impl Default for Lexer {
    fn default() -> Self {
        Self {
            source: Vec::new(),
            line: 1,
            column: 0,
            offset: 0,
            line_offset: 0,
        }
    }
}

impl Lexer {
    pub fn tokenize(&mut self) -> Vec<Token> {
        let mut tokens = Vec::new();

        loop {
            let tok = self.next_token();
            let kind = tok.kind.clone();
            tokens.push(tok);

            if kind.is_special(Special::Eof) {
                return tokens;
            }
        }
    }

    fn next_token(&mut self) -> Token {
        self.skip_whitespace_and_comments();

        let current = self.peek();
        if current == '\0' {
            return Token::new(
                TokenKind::Special(Special::Eof),
                Span::new(self.position(), None),
            );
        }

        if current.is_ascii_alphabetic() || current == '_' {
            return self.handle_identifier();
        }

        if current.is_ascii_digit() {
            return self.handle_numbers();
        }

        if current == '"' {
            return self.handle_string_literal();
        }

        match current {
            // delimiters
            '(' => self.make_single(TokenKind::Delimiter(Delimiter::LeftParen)),
            ')' => self.make_single(TokenKind::Delimiter(Delimiter::RightParen)),
            '[' => self.make_single(TokenKind::Delimiter(Delimiter::LeftBracket)),
            ']' => self.make_single(TokenKind::Delimiter(Delimiter::RightBracket)),
            '{' => self.make_single(TokenKind::Delimiter(Delimiter::LeftBrace)),
            '}' => self.make_single(TokenKind::Delimiter(Delimiter::RightBrace)),
            ':' => self.make_single(TokenKind::Delimiter(Delimiter::Colon)),
            ';' => self.make_single(TokenKind::Delimiter(Delimiter::Semicolon)),
            ',' => self.make_single(TokenKind::Delimiter(Delimiter::Comma)),

            // operators
            '+' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::PlusEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Plus)),
            },
            '-' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::MinusEqual)),
                '>' => self.make_double(TokenKind::Operator(Operator::Arrow)),
                _ => self.make_single(TokenKind::Operator(Operator::Minus)),
            },
            '*' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::StarEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Star)),
            },
            '/' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::SlashEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Slash)),
            },
            '=' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::EqualEqual)),
                '>' => self.make_double(TokenKind::Operator(Operator::FatArrow)),
                _ => self.make_single(TokenKind::Operator(Operator::Equal)),
            },
            '!' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::BangEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Bang)),
            },
            '<' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::LessEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Less)),
            },
            '>' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::GreaterEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Greater)),
            },
            '.' => self.make_single(TokenKind::Operator(Operator::Dot)),
            '?' => self.make_single(TokenKind::Operator(Operator::Question)),
            _ => self.make_error_token(format!("Unexpected character '{current}'")),
        }
    }

    fn handle_identifier(&mut self) -> Token {
        let start = self.position();
        self.advance(); // skip the first char which is a valid alpha or _ char
        while !self.is_at_end() && (self.peek().is_ascii_alphanumeric() || self.peek() == '_') {
            self.advance();
        }

        let span = Span::new(start, Some(self.position()));

        let literal = self.source[start.offset..self.offset]
            .to_vec()
            .iter()
            .collect::<String>();

        let kw = Keyword::try_from(literal.as_ref());
        if let Ok(kw) = kw {
            return Token::new(TokenKind::Keyword(kw), span);
        }

        Token::new(TokenKind::Identifier(literal), span)
    }

    fn handle_numbers(&mut self) -> Token {
        let start = self.position();
        self.advance(); // skip the first number that we already checked.
        while !self.is_at_end() && self.peek().is_ascii_digit() {
            self.advance();
        }

        if self.peek() == '.' && self.peek_next().is_ascii_digit() {
            self.advance(); // skip over period
            while !self.is_at_end() && self.peek().is_ascii_digit() {
                self.advance();
            }
        }

        let span = Span::new(start, Some(self.position()));
        let literal: String = self.source[start.offset..self.offset].iter().collect();
        Token::new(TokenKind::Number(literal), span)
    }

    fn handle_string_literal(&mut self) -> Token {
        self.advance(); // skip "
        let start = self.position();

        while !self.is_at_end() && self.peek() != '"' {
            self.advance();
        }

        if self.peek() != '"' {
            return self.make_error_token("unterminated string literal".into());
        }

        let end = self.position();
        let span = Span::new(start, Some(end));
        let literal = self.source[start.offset..end.offset]
            .iter()
            .collect::<String>();

        let tok = Token::new(TokenKind::String(literal), span);

        self.advance(); // advance over the " for the next token
        return tok;
    }

    fn position(&mut self) -> Position {
        Position::new(self.line, self.column, self.offset)
    }

    fn is_at_end(&mut self) -> bool {
        self.offset >= self.source.len()
    }

    fn advance(&mut self) {
        match self.peek() {
            '\n' => {
                self.offset += 1;
                self.line += 1;
                self.column = 0;
                self.line_offset = self.offset;
            }
            '\0' => return,
            _ => {
                self.offset += 1;
                self.column += 1;
            }
        }
    }

    fn peek(&mut self) -> char {
        self.peek_at(self.offset)
    }

    fn peek_next(&mut self) -> char {
        self.peek_at(self.offset + 1)
    }

    fn peek_at(&mut self, offset: usize) -> char {
        if offset >= self.source.len() {
            return '\0';
        }

        return self.source[offset];
    }

    fn make_error_token(&mut self, err: String) -> Token {
        let start = self.position();
        self.advance();
        let span = Span::new(start, None);
        Token::new(TokenKind::Special(Special::Error(err)), span)
    }

    fn make_single(&mut self, kind: TokenKind) -> Token {
        let start = self.position();
        self.advance();
        let end = Some(self.position());
        let span = Span::new(start, end);
        Token::new(kind, span)
    }

    fn make_double(&mut self, kind: TokenKind) -> Token {
        let start = self.position();
        self.advance();
        self.advance();
        let end = Some(self.position());
        let span = Span::new(start, end);
        Token::new(kind, span)
    }

    fn skip_whitespace(&mut self) {
        loop {
            match self.peek() {
                '\r' | '\t' | '\n' | ' ' => self.advance(),
                _ => return,
            }
        }
    }

    fn skip_comments(&mut self) {
        while self.peek() != '\n' {
            self.advance();
        }
    }

    fn skip_whitespace_and_comments(&mut self) {
        loop {
            self.skip_whitespace();
            match (self.peek(), self.peek_next()) {
                ('/', '/') => self.skip_comments(),
                _ => return,
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::{keywords::Keyword, tokens::Operator};

    use super::*;

    #[test]
    pub fn lexer_can_tokenize_all_delimiters() {
        let source = "()[]{}:;,";
        let mut lexer = Lexer::default();
        lexer.source = source.chars().collect();

        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));

        assert!(tokens[0].kind.is_delimiter(Delimiter::LeftParen));
        assert!(tokens[1].kind.is_delimiter(Delimiter::RightParen));
        assert!(tokens[2].kind.is_delimiter(Delimiter::LeftBracket));
        assert!(tokens[3].kind.is_delimiter(Delimiter::RightBracket));
        assert!(tokens[4].kind.is_delimiter(Delimiter::LeftBrace));
        assert!(tokens[5].kind.is_delimiter(Delimiter::RightBrace));
        assert!(tokens[6].kind.is_delimiter(Delimiter::Colon));
        assert!(tokens[7].kind.is_delimiter(Delimiter::Semicolon));
        assert!(tokens[8].kind.is_delimiter(Delimiter::Comma));
    }

    #[test]
    pub fn lexer_can_tokenize_all_keywords() {
        let source = r#"
            if 
            else 
            class 
            return 
            continue 
            break 
            let 
            nil 
            while 
            for 
            fn 
            this 
            super
            true
            false    
        "#;

        let mut lexer = Lexer::default();
        lexer.source = source.chars().collect();

        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));

        assert!(tokens[0].kind.is_keyword(Keyword::If));
        assert!(tokens[1].kind.is_keyword(Keyword::Else));
        assert!(tokens[2].kind.is_keyword(Keyword::Class));
        assert!(tokens[3].kind.is_keyword(Keyword::Return));
        assert!(tokens[4].kind.is_keyword(Keyword::Continue));
        assert!(tokens[5].kind.is_keyword(Keyword::Break));
        assert!(tokens[6].kind.is_keyword(Keyword::Let));
        assert!(tokens[7].kind.is_keyword(Keyword::Nil));
        assert!(tokens[8].kind.is_keyword(Keyword::While));
        assert!(tokens[9].kind.is_keyword(Keyword::For));
        assert!(tokens[10].kind.is_keyword(Keyword::Function));
        assert!(tokens[11].kind.is_keyword(Keyword::This));
        assert!(tokens[12].kind.is_keyword(Keyword::Super));
        assert!(tokens[13].kind.is_keyword(Keyword::True));
        assert!(tokens[14].kind.is_keyword(Keyword::False));
    }

    #[test]
    pub fn lexer_can_tokenize_all_operators() {
        let source = "+ += - -= * *= / /= = == ! != < <= > >= . -> => ?";
        let mut lexer = Lexer::default();
        lexer.source = source.chars().collect();

        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));

        assert!(tokens[0].kind.is_operator(Operator::Plus));
        assert!(tokens[1].kind.is_operator(Operator::PlusEqual));
        assert!(tokens[2].kind.is_operator(Operator::Minus));
        assert!(tokens[3].kind.is_operator(Operator::MinusEqual));
        assert!(tokens[4].kind.is_operator(Operator::Star));
        assert!(tokens[5].kind.is_operator(Operator::StarEqual));
        assert!(tokens[6].kind.is_operator(Operator::Slash));
        assert!(tokens[7].kind.is_operator(Operator::SlashEqual));
        assert!(tokens[8].kind.is_operator(Operator::Equal));
        assert!(tokens[9].kind.is_operator(Operator::EqualEqual));
        assert!(tokens[10].kind.is_operator(Operator::Bang));
        assert!(tokens[11].kind.is_operator(Operator::BangEqual));
        assert!(tokens[12].kind.is_operator(Operator::Less));
        assert!(tokens[13].kind.is_operator(Operator::LessEqual));
        assert!(tokens[14].kind.is_operator(Operator::Greater));
        assert!(tokens[15].kind.is_operator(Operator::GreaterEqual));
        assert!(tokens[16].kind.is_operator(Operator::Dot));
        assert!(tokens[17].kind.is_operator(Operator::Arrow));
        assert!(tokens[18].kind.is_operator(Operator::FatArrow));
        assert!(tokens[19].kind.is_operator(Operator::Question));
    }

    #[test]
    pub fn lexer_can_produce_number_tokens() {
        let source = "1 1.2 1.0 432";
        let mut lexer = Lexer::default();
        lexer.source = source.chars().collect();
        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));

        assert_eq!(TokenKind::Number("1".into()), tokens[0].kind);
        assert_eq!(TokenKind::Number("1.2".into()), tokens[1].kind);
        assert_eq!(TokenKind::Number("1.0".into()), tokens[2].kind);
        assert_eq!(TokenKind::Number("432".into()), tokens[3].kind);
    }

    #[test]
    pub fn lexer_produces_eof_token_for_empty_input() {
        let mut lexer = Lexer::default();
        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));
    }

    #[test]
    pub fn lexer_handles_string_literals() {
        let mut lexer = Lexer::default();
        lexer.source = r#""a raw string""#.chars().collect();
        let tokens = lexer.tokenize();
        assert_eq!(2, tokens.len());
        assert_eq!(TokenKind::String("a raw string".into()), tokens[0].kind);
    }
}


// ===== End of src/lexer.rs =====

// ===== File: src/main.rs =====

pub mod ast;
pub mod error_handling;
pub mod heap;
pub mod keywords;
pub mod lexer;
pub mod object;
pub mod parser;
pub mod tokens;
pub mod types;
pub mod value;

fn main() {
    println!("Hello, world!");
}


// ===== End of src/main.rs =====

// ===== File: src/object.rs =====

use std::{cell::RefCell, rc::Rc};

/// Represents any reference type object that
/// is to be heap allocated
#[derive(Debug, Clone, PartialEq)]
pub enum Object {
    String(String),
}

/// HeapObject is a wrapper type that contains metadata about
/// an object for garbage collection and memory management.
#[derive(Debug, Clone, PartialEq)]
pub struct HeapObject {
    /// When true, the object was reachable from GC roots
    /// meaning that the object should not be collected.
    pub marked: bool,
    /// Next is the next object in the intrusive list. When None,
    /// we've reached the end.
    pub next: Option<Rc<RefCell<HeapObject>>>,
    /// Object is the actual object contents stored in the wrapper.
    pub object: Object,
}

impl HeapObject {
    pub fn new(object: Object, next: Option<Rc<RefCell<HeapObject>>>) -> Self {
        Self {
            marked: false,
            next,
            object,
        }
    }

    /// Get a slice of all child objects that this object references.
    ///
    /// # Returns
    /// * A slice of objects referenced by this object.
    pub fn children(&self) -> Vec<Rc<RefCell<HeapObject>>> {
        match &self.object {
            Object::String(_) => vec![],
        }
    }

    /// Get the heap size of the object.
    pub fn size(&self) -> usize {
        let self_size = std::mem::size_of::<Self>();
        let obj_size = match &self.object {
            Object::String(s) => s.capacity(),
        };

        self_size + obj_size
    }
}


// ===== End of src/object.rs =====

// ===== File: src/parser.rs =====

use crate::{
    ast::{BinaryOperator, Expression, Program, Statement, UnaryOperator},
    error_handling::Span,
    keywords::Keyword,
    tokens::{Delimiter, Operator, Special, Token, TokenKind},
    types::Type,
};

#[derive(Debug, Clone)]
pub struct Parser {
    current: usize,
    tokens: Vec<Token>,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self { current: 0, tokens }
    }

    pub fn parse(&mut self) -> Program {
        let mut program = Program::default();

        while !self.is_at_end() {
            let stmt = self.parse_statement();
            program.statements.push(stmt);
        }

        program
    }

    fn parse_statement(&mut self) -> Statement {
        match &self.peek().kind {
            TokenKind::Keyword(Keyword::Let) => self.parse_var_declaration(),
            _ => {
                // Default to expression statement
                let expr = self.parse_expression();
                self.consume_delimiter(Delimiter::Semicolon);
                Statement::ExpressionStatement(expr)
            }
        }
    }

    fn parse_type(&mut self) -> Type {
        let base_type = if let TokenKind::Identifier(type_name) = &self.peek().kind {
            let name = type_name.as_str();
            self.advance();

            match name {
                "Number" => Type::Number,
                "Bool" => Type::Bool,
                "String" => Type::String,
                "Nil" => panic!("Cannot declare variables of type Nil"),
                _ => Type::Class(type_name.clone()),
            }
        } else {
            panic!("Expected type name");
        };

        // Check for optional `?` suffix
        if self.peek().kind.is_operator(Operator::Question) {
            self.advance(); // consume '?'
            Type::Nullable(Box::new(base_type))
        } else {
            base_type
        }
    }

    fn parse_var_declaration(&mut self) -> Statement {
        self.advance(); // consume 'let'

        // Parse variable name
        let name = if let TokenKind::Identifier(id) = &self.peek().kind {
            let n = id.clone();
            self.advance();
            n
        } else {
            panic!("Expected identifier after 'let'");
        };

        // Require colon
        if !self.peek().kind.is_delimiter(Delimiter::Colon) {
            panic!("Expected ':' after variable name");
        }
        self.advance(); // consume ':'

        // Parse type annotation (required)
        let type_annotation = self.parse_type();

        // Require equals sign
        if !self.peek().kind.is_operator(Operator::Equal) {
            panic!("Variable must be initialized - no default values allowed");
        }
        self.advance(); // consume '='

        // Parse initializer expression
        let initializer = self.parse_expression();
        println!("INITIALIZER: {:#?}", initializer);

        // Consume semicolon
        self.consume_delimiter(Delimiter::Semicolon);

        Statement::VarDeclaration {
            name,
            type_annotation,
            initializer,
        }
    }

    fn parse_expression(&mut self) -> Expression {
        self.parse_logical_or()
    }

    fn parse_logical_or(&mut self) -> Expression {
        let mut expr = self.parse_logical_and();

        while self.peek().kind.is_keyword(Keyword::Or) {
            self.advance();
            let right = self.parse_logical_and();
            expr = Expression::Binary {
                left: Box::new(expr),
                operator: BinaryOperator::LogicalOr,
                right: Box::new(right),
            };
        }

        expr
    }

    fn parse_logical_and(&mut self) -> Expression {
        let mut expr = self.parse_equality();

        while self.peek().kind.is_keyword(Keyword::And) {
            self.advance();
            let right = self.parse_equality();
            expr = Expression::Binary {
                left: Box::new(expr),
                operator: BinaryOperator::LogicalAnd,
                right: Box::new(right),
            };
        }

        expr
    }

    fn parse_equality(&mut self) -> Expression {
        let mut expr = self.parse_comparison(); // left operand.
        while let TokenKind::Operator(op) = self.peek().kind {
            match op {
                Operator::EqualEqual => {
                    self.advance(); // consume '=='
                    let right = self.parse_comparison(); // Get right operand
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Equal,
                        right: Box::new(right),
                    };
                }
                Operator::BangEqual => {
                    self.advance(); // consume '!='
                    let right = self.parse_comparison();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::NotEqual,
                        right: Box::new(right),
                    };
                }
                _ => break, // Not a comparison operator
            }
        }

        expr
    }

    fn parse_comparison(&mut self) -> Expression {
        let mut expr = self.parse_term(); // Get left operand

        while let TokenKind::Operator(op) = self.peek().kind {
            match op {
                Operator::Less => {
                    self.advance(); // consume '<'
                    let right = self.parse_term(); // Get right operand
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Less,
                        right: Box::new(right),
                    };
                }
                Operator::LessEqual => {
                    self.advance(); // consume '<='
                    let right = self.parse_term();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::LessEqual,
                        right: Box::new(right),
                    };
                }
                Operator::Greater => {
                    self.advance(); // consume '>'
                    let right = self.parse_term();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Greater,
                        right: Box::new(right),
                    };
                }
                Operator::GreaterEqual => {
                    self.advance(); // consume '>='
                    let right = self.parse_term();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::GreaterEqual,
                        right: Box::new(right),
                    };
                }
                _ => break, // Not a comparison operator
            }
        }

        expr
    }

    fn parse_term(&mut self) -> Expression {
        let mut expr = self.parse_factor(); // Get left operand

        while let TokenKind::Operator(op) = self.peek().kind {
            match op {
                Operator::Plus => {
                    self.advance(); // consume '+'
                    let right = self.parse_factor(); // Get right operand
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Add,
                        right: Box::new(right),
                    };
                }
                Operator::Minus => {
                    self.advance(); // consume '-'
                    let right = self.parse_factor();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Subtract,
                        right: Box::new(right),
                    };
                }
                _ => break, // Not a term-level operator
            }
        }

        expr
    }

    fn parse_factor(&mut self) -> Expression {
        let mut expr = self.parse_unary(); // Get left operand

        while let TokenKind::Operator(op) = self.peek().kind {
            match op {
                Operator::Star => {
                    self.advance(); // consume '*'
                    let right = self.parse_unary(); // Get right operand
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Multiply,
                        right: Box::new(right),
                    };
                }
                Operator::Slash => {
                    self.advance(); // consume '/'
                    let right = self.parse_unary();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Divide,
                        right: Box::new(right),
                    };
                }
                _ => break, // Not a factor-level operator
            }
        }

        expr
    }

    fn parse_unary(&mut self) -> Expression {
        let kind = self.peek().kind;

        if kind.is_operator(Operator::Bang) {
            self.advance();
            let expr = self.parse_unary();
            return Expression::Unary {
                operator: UnaryOperator::Not,
                operand: Box::new(expr),
            };
        } else if kind.is_operator(Operator::Minus) {
            self.advance();
            let expr = self.parse_unary();
            return Expression::Unary {
                operator: UnaryOperator::Negate,
                operand: Box::new(expr),
            };
        } else {
            self.parse_primary()
        }
    }

    fn parse_primary(&mut self) -> Expression {
        let kind = self.peek().kind;
        match kind {
            TokenKind::Number(literal) => self.handle_number_literal(literal),
            TokenKind::String(literal) => self.handle_string_literal(literal),
            TokenKind::Keyword(Keyword::True) | TokenKind::Keyword(Keyword::False) => {
                self.handle_boolean_literal()
            }
            TokenKind::Keyword(Keyword::Nil) => self.handle_nil_literal(),
            TokenKind::Identifier(_) => self.handle_identifier(),
            TokenKind::Delimiter(Delimiter::LeftParen) => self.handle_grouped_expression(),
            _ => Expression::Nil,
        }
    }

    fn handle_number_literal(&mut self, literal: String) -> Expression {
        let result = literal.parse::<f64>();
        if let Err(e) = result {
            panic!("ERROR PARSING NUMBER LITERAL: {e}");
        }

        self.advance();
        Expression::Number(result.unwrap())
    }

    fn handle_string_literal(&mut self, literal: String) -> Expression {
        self.advance();
        Expression::String(literal)
    }

    fn handle_boolean_literal(&mut self) -> Expression {
        let kind = self.peek().kind;

        let expr = if kind.is_keyword(Keyword::True) {
            Expression::Bool(true)
        } else if kind.is_keyword(Keyword::False) {
            Expression::Bool(false)
        } else {
            unreachable!()
        };

        self.advance();
        expr
    }

    fn handle_nil_literal(&mut self) -> Expression {
        self.advance();
        Expression::Nil
    }

    fn handle_identifier(&mut self) -> Expression {
        if let TokenKind::Identifier(name) = &self.peek().kind {
            let identifier = name.clone();
            self.advance();
            Expression::Identifier(identifier)
        } else {
            panic!("Expected identifier");
        }
    }

    fn handle_grouped_expression(&mut self) -> Expression {
        self.consume_delimiter(Delimiter::LeftParen);
        let expr = self.parse_expression();
        self.consume_delimiter(Delimiter::RightParen);

        expr
    }

    fn advance(&mut self) {
        if self.is_at_end() {
            return;
        }

        self.current += 1;
    }

    fn consume_delimiter(&mut self, expected: Delimiter) {
        let kind = self.peek().kind;
        let ok = match kind {
            TokenKind::Delimiter(actual) => actual == expected,
            _ => false,
        };

        self.advance();

        // TODO: add error handling to parser, we'll just panic instead.
        if !ok {
            panic!("Expected {:#?}, Got: {:#?}", expected, kind);
        }
    }

    fn peek(&self) -> Token {
        let default = Token::new(TokenKind::Special(Special::Eof), Span::default());
        self.tokens
            .get(self.current)
            .map(|thing| thing.to_owned())
            .unwrap_or_else(|| default)
    }

    fn is_at_end(&self) -> bool {
        matches!(self.peek().kind, TokenKind::Special(Special::Eof))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{ast::UnaryOperator, lexer::Lexer, parser::Parser};

    #[test]
    pub fn parser_can_parse_simple_numbers() {
        let mut lexer = Lexer::default();
        lexer.source = "1.23;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Number(1.23))],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_simple_booleans() {
        let mut lexer = Lexer::default();
        lexer.source = "true;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();
        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Bool(true))],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_nil_literals() {
        let mut lexer = Lexer::default();
        lexer.source = "nil;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();
        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Nil)],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_basic_groupings() {
        let mut lexer = Lexer::default();
        lexer.source = "(true);".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Bool(true))],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_unary_logical_not_expressions() {
        let mut lexer = Lexer::default();
        lexer.source = "!true;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Unary {
                operator: UnaryOperator::Not,
                operand: Box::new(Expression::Bool(true)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_unary_negation_expressions() {
        let mut lexer = Lexer::default();
        lexer.source = "-5;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Unary {
                operator: UnaryOperator::Negate,
                operand: Box::new(Expression::Number(5.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_simple_binary_factor() {
        let mut lexer = Lexer::default();
        lexer.source = "1 * 2;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(1.)),
                operator: BinaryOperator::Multiply,
                right: Box::new(Expression::Number(2.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_simple_binary_term() {
        let mut lexer = Lexer::default();
        lexer.source = "1 - 2;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(1.)),
                operator: BinaryOperator::Subtract,
                right: Box::new(Expression::Number(2.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_simple_comparison() {
        let mut lexer = Lexer::default();
        lexer.source = "5 < 10;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(5.)),
                operator: BinaryOperator::Less,
                right: Box::new(Expression::Number(10.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_equality_when_equal() {
        let mut lexer = Lexer::default();
        lexer.source = "5 == 10;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(5.)),
                operator: BinaryOperator::Equal,
                right: Box::new(Expression::Number(10.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_equality_when_not_equal() {
        let mut lexer = Lexer::default();
        lexer.source = "5 != 10;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(5.)),
                operator: BinaryOperator::NotEqual,
                right: Box::new(Expression::Number(10.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_basic_identifiers() {
        let mut lexer = Lexer::default();
        lexer.source = "someIdent != 10;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Identifier("someIdent".into())),
                operator: BinaryOperator::NotEqual,
                right: Box::new(Expression::Number(10.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_logical_and() {
        let mut lexer = Lexer::default();
        lexer.source = "true and false;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Bool(true)),
                operator: BinaryOperator::LogicalAnd,
                right: Box::new(Expression::Bool(false)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_logical_or() {
        let mut lexer = Lexer::default();
        lexer.source = "false or true;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Bool(false)),
                operator: BinaryOperator::LogicalOr,
                right: Box::new(Expression::Bool(true)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_let_with_number() {
        let mut lexer = Lexer::default();
        lexer.source = "let x: Number = 42;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "x".to_string(),
                type_annotation: Type::Number,
                initializer: Expression::Number(42.0),
            }],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_let_with_bool() {
        let mut lexer = Lexer::default();
        lexer.source = "let flag: Bool = true;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "flag".to_string(),
                type_annotation: Type::Bool,
                initializer: Expression::Bool(true),
            }],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_let_with_string() {
        let mut lexer = Lexer::default();
        lexer.source = r#"let name: String = "hello";"#.chars().collect();

        let tokens = lexer.tokenize();

        println!("{:#?}", tokens);

        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "name".to_string(),
                type_annotation: Type::String,
                initializer: Expression::String("hello".to_string()), // Assuming you add string literals
            }],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_let_with_expression_initializer() {
        let mut lexer = Lexer::default();
        lexer.source = "let result: Number = 5 + 3 * 2;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "result".to_string(),
                type_annotation: Type::Number,
                initializer: Expression::Binary {
                    left: Box::new(Expression::Number(5.0)),
                    operator: BinaryOperator::Add,
                    right: Box::new(Expression::Binary {
                        left: Box::new(Expression::Number(3.0)),
                        operator: BinaryOperator::Multiply,
                        right: Box::new(Expression::Number(2.0)),
                    }),
                },
            }],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    #[should_panic(expected = "Cannot declare variables of type Nil")]
    pub fn parser_rejects_nil_type_declaration() {
        let mut lexer = Lexer::default();
        lexer.source = "let invalid: Nil = nil;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        parser.parse(); // Should panic
    }

    #[test]
    pub fn parser_can_parse_let_with_nullable_type() {
        let mut lexer = Lexer::default();
        lexer.source = "let maybe: String? = nil;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "maybe".to_string(),
                type_annotation: Type::Nullable(Box::new(Type::String)),
                initializer: Expression::Nil,
            }],
        };

        assert_eq!(expected, ast);
    }
}


// ===== End of src/parser.rs =====

// ===== File: src/tokens.rs =====

use crate::{error_handling::Span, keywords::Keyword};

#[derive(Debug, Clone, PartialEq)]
pub enum TokenKind {
    Number(String),
    String(String),
    Identifier(String),
    Keyword(Keyword),
    Operator(Operator),
    Delimiter(Delimiter),
    Special(Special),
}

impl TokenKind {
    pub fn is_keyword(&self, expected: Keyword) -> bool {
        match self {
            TokenKind::Keyword(self_kw) => *self_kw == expected,
            _ => false,
        }
    }

    pub fn is_operator(&self, expected: Operator) -> bool {
        match self {
            TokenKind::Operator(self_op) => *self_op == expected,
            _ => false,
        }
    }

    pub fn is_delimiter(&self, expected: Delimiter) -> bool {
        match self {
            TokenKind::Delimiter(self_delimiter) => *self_delimiter == expected,
            _ => false,
        }
    }

    pub fn is_special(&self, expected: Special) -> bool {
        match self {
            TokenKind::Special(self_kind) => *self_kind == expected,
            _ => false,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Operator {
    Plus,
    PlusEqual,
    Minus,
    MinusEqual,
    Star,
    StarEqual,
    Slash,
    SlashEqual,
    Equal,
    EqualEqual,
    Bang,
    BangEqual,
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Dot,
    Arrow,
    FatArrow,
    Question,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Delimiter {
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    LeftBracket,
    RightBracket,
    Colon,
    Semicolon,
    Comma,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Special {
    Eof,
    Error(String),
}

#[derive(Debug, Clone)]
pub struct Token {
    pub kind: TokenKind,
    pub span: Span,
}

impl Token {
    pub fn new(kind: TokenKind, span: Span) -> Self {
        Self { kind, span }
    }
}


// ===== End of src/tokens.rs =====

// ===== File: src/types.rs =====

use lazy_static::lazy_static;
use std::collections::HashMap;
use std::sync::RwLock;

lazy_static! {
    static ref CLASS_REGISTRY: RwLock<HashMap<String, ClassInfo>> = RwLock::new(HashMap::new());
}

struct ClassInfo {
    name: String,
    superclass: Option<String>,
}

impl ClassInfo {
    fn is_subtype_of(&self, parent: &str) -> bool {
        let mut current = self.superclass.clone();

        while let Some(super_name) = current {
            if super_name == parent {
                return true;
            }
            current = CLASS_REGISTRY
                .read()
                .unwrap()
                .get(&super_name)
                .and_then(|ci| ci.superclass.clone());
        }

        false
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Number,
    Bool,
    String,
    Nil,
    Tuple(Vec<Box<Type>>),
    NamedTuple(Vec<(String, Box<Type>)>),
    Function {
        params: Vec<Box<Type>>,
        return_types: Vec<Box<Type>>,
    },
    // User-defined types.
    Class(String), // String is the fully-qualified class name.
    // Nullable Wrapper
    Nullable(Box<Type>),
}

impl Type {
    fn is_nullable(&self) -> bool {
        if let Type::Nullable(_) = self {
            return true;
        }

        false
    }

    /// Check if this type is assignable to another type.
    pub fn is_assignable_to(&self, other: &Type) -> bool {
        match (self, other) {
            (Type::Tuple(elements_1), Type::Tuple(elements_2)) => {
                elements_1.len() == elements_2.len()
                    && elements_1
                        .iter()
                        .zip(elements_2.iter())
                        .all(|(el_1_type, el_2_type)| el_1_type.is_assignable_to(el_2_type))
            }
            (Type::NamedTuple(elements_1), Type::NamedTuple(elements_2)) => {
                elements_1.len() == elements_2.len()
                    && elements_1.iter().zip(elements_2.iter()).all(
                        |((_, el_1_type), (_, el_2_type))| el_1_type.is_assignable_to(el_2_type),
                    )
            }
            (Type::NamedTuple(named_elements), Type::Tuple(elements)) => {
                named_elements.len() == elements.len()
                    && named_elements.iter().zip(elements.iter()).all(
                        |((_, named_element_type), element_type)| {
                            named_element_type.is_assignable_to(element_type)
                        },
                    )
            }

            (Type::Tuple(elements), Type::NamedTuple(named_elements)) => {
                elements.len() == named_elements.len()
                    && elements.iter().zip(named_elements.iter()).all(
                        |(element_type, (_, named_element_type))| {
                            element_type.is_assignable_to(named_element_type)
                        },
                    )
            }
            (
                Type::Function {
                    params: params1,
                    return_types: returns1,
                },
                Type::Function {
                    params: params2,
                    return_types: returns2,
                },
            ) => {
                // Same number of parameters and return values
                if params1.len() != params2.len() || returns1.len() != returns2.len() {
                    return false;
                }

                // Parameters are contravariant: self param type must be a supertype of other param type
                let params_ok = params1
                    .iter()
                    .zip(params2.iter())
                    .all(|(self_param, other_param)| other_param.is_assignable_to(self_param));

                // Return types are covariant: self return type must be a subtype of other return type
                let returns_ok = returns1
                    .iter()
                    .zip(returns2.iter())
                    .all(|(self_ret, other_ret)| self_ret.is_assignable_to(other_ret));

                params_ok && returns_ok
            }

            (Type::Class(a_name), Type::Class(b_name)) => {
                if a_name == b_name {
                    true
                } else {
                    CLASS_REGISTRY
                        .read()
                        .unwrap()
                        .get(a_name)
                        .map_or(false, |class_info| class_info.is_subtype_of(b_name))
                }
            }

            // nil can be assigned to any nullable type
            (Type::Nil, Type::Nullable(_)) => true,

            (Type::Nullable(a), b) if !b.is_nullable() => {
                println!("a {:#?}, b {:#?}", a, b);
                false
            }
            (Type::Nullable(a), Type::Nullable(b)) => a.is_assignable_to(b),

            // Allow non-null assignment to nullable of same type.
            (a, Type::Nullable(nullable_inner)) => a.is_assignable_to(&nullable_inner),

            (a, b) if a == b => true,

            // Nothing else is assignable.
            _ => false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exact_type_matches() {
        // Built-in types should match themselves
        assert!(Type::Number.is_assignable_to(&Type::Number));
        assert!(Type::Bool.is_assignable_to(&Type::Bool));
        assert!(Type::String.is_assignable_to(&Type::String));
        assert!(Type::Nil.is_assignable_to(&Type::Nil));

        // Class types should match themselves
        let point = Type::Class("Point".to_string());
        assert!(point.is_assignable_to(&point));

        // Different classes should not match
        let point = Type::Class("Point".to_string());
        let rectangle = Type::Class("Rectangle".to_string());
        assert!(!point.is_assignable_to(&rectangle));
    }

    #[test]
    fn test_nil_to_nullable_assignment() {
        // nil can be assigned to any nullable type
        assert!(Type::Nil.is_assignable_to(&Type::Nullable(Box::new(Type::Number))));
        assert!(Type::Nil.is_assignable_to(&Type::Nullable(Box::new(Type::String))));
        assert!(Type::Nil.is_assignable_to(&Type::Nullable(Box::new(Type::Bool))));

        // nil can be assigned to nullable class types
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        assert!(Type::Nil.is_assignable_to(&nullable_point));

        // nil cannot be assigned to non-nullable types
        assert!(!Type::Nil.is_assignable_to(&Type::Number));
        assert!(!Type::Nil.is_assignable_to(&Type::String));
        assert!(!Type::Nil.is_assignable_to(&Type::Class("Point".to_string())));
    }

    #[test]
    fn test_non_null_to_nullable_assignment() {
        // Built-in types can be assigned to their nullable versions
        assert!(Type::Number.is_assignable_to(&Type::Nullable(Box::new(Type::Number))));
        assert!(Type::String.is_assignable_to(&Type::Nullable(Box::new(Type::String))));
        assert!(Type::Bool.is_assignable_to(&Type::Nullable(Box::new(Type::Bool))));

        // Class types can be assigned to their nullable versions
        let point = Type::Class("Point".to_string());
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        assert!(point.is_assignable_to(&nullable_point));

        // Wrong types cannot be assigned to nullable of different type
        assert!(!Type::Number.is_assignable_to(&Type::Nullable(Box::new(Type::String))));
        assert!(!Type::String.is_assignable_to(&Type::Nullable(Box::new(Type::Number))));
    }

    #[test]
    fn test_nullable_cannot_be_assigned_to_non_nullable() {
        // Nullable types cannot be assigned to non-nullable versions
        let nullable_int = Type::Nullable(Box::new(Type::Number));
        assert!(!nullable_int.is_assignable_to(&Type::Number));

        let nullable_string = Type::Nullable(Box::new(Type::String));
        assert!(!nullable_string.is_assignable_to(&Type::String));

        // Nullable classes cannot be assigned to non-nullable classes
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        let point = Type::Class("Point".to_string());
        assert!(!nullable_point.is_assignable_to(&point));
    }

    #[test]
    fn test_nullable_type_equality() {
        // Nullable types should be equal to themselves
        let nullable_int = Type::Nullable(Box::new(Type::Number));
        let another_nullable_int = Type::Nullable(Box::new(Type::Number));
        assert!(nullable_int.is_assignable_to(&another_nullable_int));

        // Different nullable types should not be equal
        let nullable_int = Type::Nullable(Box::new(Type::Number));
        let nullable_string = Type::Nullable(Box::new(Type::String));
        assert!(!nullable_int.is_assignable_to(&nullable_string));

        // Nullable class types
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        let another_nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        assert!(nullable_point.is_assignable_to(&another_nullable_point));
    }

    #[test]
    fn test_incompatible_type_assignments() {
        // Built-in types cannot be assigned to each other
        assert!(!Type::Number.is_assignable_to(&Type::String));
        assert!(!Type::Bool.is_assignable_to(&Type::Number));
        assert!(!Type::String.is_assignable_to(&Type::Bool));

        // Classes cannot be assigned to built-in types
        let point = Type::Class("Point".to_string());
        assert!(!point.is_assignable_to(&Type::Number));
        assert!(!point.is_assignable_to(&Type::String));
        assert!(!Type::String.is_assignable_to(&point));

        // Different classes cannot be assigned to each other
        let point = Type::Class("Point".to_string());
        let rectangle = Type::Class("Rectangle".to_string());
        assert!(!point.is_assignable_to(&rectangle));
        assert!(!rectangle.is_assignable_to(&point));
    }

    #[test]
    fn test_fully_qualified_class_names() {
        // Different fully-qualified names should be different types
        let local_point = Type::Class("Point".to_string());
        let graphics_point = Type::Class("graphics.Point".to_string());
        let math_point = Type::Class("math.Point".to_string());

        assert!(!local_point.is_assignable_to(&graphics_point));
        assert!(!graphics_point.is_assignable_to(&math_point));
        assert!(!math_point.is_assignable_to(&local_point));

        // But same fully-qualified names should match
        let point1 = Type::Class("graphics.Point".to_string());
        let point2 = Type::Class("graphics.Point".to_string());
        assert!(point1.is_assignable_to(&point2));
    }

    #[test]
    fn test_nullable_class_types() {
        let point = Type::Class("Point".to_string());
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));

        // Point can be assigned to Point?
        assert!(point.is_assignable_to(&nullable_point));

        // Point? cannot be assigned to Point
        assert!(!nullable_point.is_assignable_to(&point));

        // nil can be assigned to Point?
        assert!(Type::Nil.is_assignable_to(&nullable_point));
    }

    #[test]
    fn test_tuple_types() {
        // Empty tuple (unit type)
        let unit = Type::Tuple(vec![]);
        assert!(unit.is_assignable_to(&unit));

        // Simple tuple
        let int_string_tuple = Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);

        // Same tuple structure should match
        let another_int_string_tuple =
            Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);
        assert!(int_string_tuple.is_assignable_to(&another_int_string_tuple));

        // Different tuple structures should not match
        let string_int_tuple = Type::Tuple(vec![Box::new(Type::String), Box::new(Type::Number)]);
        assert!(!int_string_tuple.is_assignable_to(&string_int_tuple));
    }

    #[test]
    fn test_named_tuple_types() {
        // Named tuple for function return
        let divide_result = Type::NamedTuple(vec![
            ("result".to_string(), Box::new(Type::Number)),
            (
                "error".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
        ]);

        // Same named tuple should match
        let another_divide_result = Type::NamedTuple(vec![
            ("result".to_string(), Box::new(Type::Number)),
            (
                "error".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
        ]);
        assert!(divide_result.is_assignable_to(&another_divide_result));

        // Different field names should not match
        let different_names = Type::NamedTuple(vec![
            ("value".to_string(), Box::new(Type::Number)),
            (
                "message".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
        ]);
        assert!(divide_result.is_assignable_to(&different_names));

        // Different field order should not match
        let different_order = Type::NamedTuple(vec![
            (
                "error".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
            ("result".to_string(), Box::new(Type::Number)),
        ]);
        assert!(!divide_result.is_assignable_to(&different_order));
    }

    #[test]
    fn test_function_types() {
        // Simple function: (Number, Number) -> Number
        let add_function = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Number)],
        };

        // Same function signature should match
        let another_add_function = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Number)],
        };
        assert!(add_function.is_assignable_to(&another_add_function));

        // Different return types should not match
        let string_function = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        };
        assert!(!add_function.is_assignable_to(&string_function));

        // Multiple return values
        let multi_return_function = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Number), Box::new(Type::String)],
        };

        // Different number of return values should not match
        assert!(!add_function.is_assignable_to(&multi_return_function));
    }

    #[test]
    fn test_nullable_complex_types() {
        // Nullable tuple
        let nullable_tuple = Type::Nullable(Box::new(Type::Tuple(vec![
            Box::new(Type::Number),
            Box::new(Type::String),
        ])));

        // Regular tuple can be assigned to nullable tuple
        let regular_tuple = Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);
        assert!(regular_tuple.is_assignable_to(&nullable_tuple));

        // nil can be assigned to nullable tuple
        assert!(Type::Nil.is_assignable_to(&nullable_tuple));

        // Nullable function
        let nullable_function = Type::Nullable(Box::new(Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        }));

        let regular_function = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        };
        assert!(regular_function.is_assignable_to(&nullable_function));
        assert!(Type::Nil.is_assignable_to(&nullable_function));

        // Nullable named tuple
        let nullable_named_tuple = Type::Nullable(Box::new(Type::NamedTuple(vec![(
            "result".to_string(),
            Box::new(Type::Number),
        )])));

        let regular_named_tuple =
            Type::NamedTuple(vec![("result".to_string(), Box::new(Type::Number))]);
        assert!(regular_named_tuple.is_assignable_to(&nullable_named_tuple));
        assert!(Type::Nil.is_assignable_to(&nullable_named_tuple));
    }

    #[test]
    fn test_tuple_named_tuple_interchangeability() {
        // Plain tuple and named tuple with same structure should be interchangeable
        let plain_tuple = Type::Tuple(vec![
            Box::new(Type::Number),
            Box::new(Type::String),
            Box::new(Type::Bool),
        ]);

        let named_tuple = Type::NamedTuple(vec![
            ("first".to_string(), Box::new(Type::Number)),
            ("second".to_string(), Box::new(Type::String)),
            ("third".to_string(), Box::new(Type::Bool)),
        ]);

        // Both directions should work
        assert!(plain_tuple.is_assignable_to(&named_tuple));
        assert!(named_tuple.is_assignable_to(&plain_tuple));

        // Different lengths should not be assignable
        let shorter_plain = Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);
        assert!(!plain_tuple.is_assignable_to(&shorter_plain));
        assert!(!named_tuple.is_assignable_to(&shorter_plain));
    }

    #[test]
    fn test_tuple_assignability_with_nullable() {
        // Tuple with non-nullable element
        let plain_tuple = Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);

        // Tuple with nullable element
        let nullable_tuple = Type::Tuple(vec![
            Box::new(Type::Number),
            Box::new(Type::Nullable(Box::new(Type::String))),
        ]);

        // Non-nullable tuple should be assignable to nullable tuple
        assert!(plain_tuple.is_assignable_to(&nullable_tuple));

        // Nullable tuple should NOT be assignable to non-nullable tuple
        assert!(!nullable_tuple.is_assignable_to(&plain_tuple));

        // Same test with named tuples
        let plain_named = Type::NamedTuple(vec![
            ("id".to_string(), Box::new(Type::Number)),
            ("name".to_string(), Box::new(Type::String)),
        ]);

        let nullable_named = Type::NamedTuple(vec![
            ("id".to_string(), Box::new(Type::Number)),
            (
                "name".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
        ]);

        assert!(plain_named.is_assignable_to(&nullable_named));
        assert!(!nullable_named.is_assignable_to(&plain_named));
    }

    #[test]
    fn test_function_assignability_exact_match() {
        // Simple function: (Number, String) -> Bool
        let func1 = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::String)],
            return_types: vec![Box::new(Type::Bool)],
        };

        // Exact same signature
        let func2 = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::String)],
            return_types: vec![Box::new(Type::Bool)],
        };

        // Should be assignable to each other
        assert!(func1.is_assignable_to(&func2));
        assert!(func2.is_assignable_to(&func1));
    }

    #[test]
    fn test_function_assignability_parameter_mismatch() {
        let base_func = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::String)],
            return_types: vec![Box::new(Type::Bool)],
        };

        // Different parameter count
        let fewer_params = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Bool)],
        };
        assert!(!base_func.is_assignable_to(&fewer_params));
        assert!(!fewer_params.is_assignable_to(&base_func));

        // Different parameter types
        let different_param_types = Type::Function {
            params: vec![Box::new(Type::String), Box::new(Type::String)], // Number -> Number
            return_types: vec![Box::new(Type::Bool)],
        };
        assert!(!base_func.is_assignable_to(&different_param_types));
        assert!(!different_param_types.is_assignable_to(&base_func));

        // Different parameter order
        let swapped_params = Type::Function {
            params: vec![Box::new(Type::String), Box::new(Type::Number)], // Swapped order
            return_types: vec![Box::new(Type::Bool)],
        };
        assert!(!base_func.is_assignable_to(&swapped_params));
        assert!(!swapped_params.is_assignable_to(&base_func));
    }

    #[test]
    fn test_function_assignability_return_type_mismatch() {
        let base_func = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        };

        // Different return type
        let different_return = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Bool)], // String -> Bool
        };
        assert!(!base_func.is_assignable_to(&different_return));
        assert!(!different_return.is_assignable_to(&base_func));

        // Different number of return values
        let multiple_returns = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String), Box::new(Type::Bool)],
        };
        assert!(!base_func.is_assignable_to(&multiple_returns));
        assert!(!multiple_returns.is_assignable_to(&base_func));

        // Void function vs non-void
        let void_func = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![],
        };
        assert!(!base_func.is_assignable_to(&void_func));
        assert!(!void_func.is_assignable_to(&base_func));
    }

    #[test]
    fn test_function_assignability_with_tuples() {
        // Function returning plain tuple
        let plain_tuple_func = Type::Function {
            params: vec![],
            return_types: vec![Box::new(Type::Tuple(vec![
                Box::new(Type::Number),
                Box::new(Type::String),
            ]))],
        };

        // Function returning named tuple with same structure
        let named_tuple_func = Type::Function {
            params: vec![],
            return_types: vec![Box::new(Type::NamedTuple(vec![
                ("result".to_string(), Box::new(Type::Number)),
                ("message".to_string(), Box::new(Type::String)),
            ]))],
        };

        // Should be assignable due to tuple/named tuple interchangeability
        assert!(plain_tuple_func.is_assignable_to(&named_tuple_func));
        assert!(named_tuple_func.is_assignable_to(&plain_tuple_func));
    }

    #[test]
    fn test_function_assignability_multiple_return_values() {
        // Function with multiple return values
        let multi_return = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![
                Box::new(Type::Number),
                Box::new(Type::String),
                Box::new(Type::Bool),
            ],
        };

        // Same signature
        let same_multi_return = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![
                Box::new(Type::Number),
                Box::new(Type::String),
                Box::new(Type::Bool),
            ],
        };

        assert!(multi_return.is_assignable_to(&same_multi_return));

        // Different order of return types
        let different_order_returns = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![
                Box::new(Type::String),
                Box::new(Type::Number),
                Box::new(Type::Bool),
            ],
        };
        assert!(!multi_return.is_assignable_to(&different_order_returns));
    }

    #[test]
    fn test_function_assignability_with_nullable_parameters() {
        // Function with non-nullable parameter
        let non_nullable_param = Type::Function {
            params: vec![Box::new(Type::String)],
            return_types: vec![Box::new(Type::Number)],
        };

        // Function with nullable parameter
        let nullable_param = Type::Function {
            params: vec![Box::new(Type::Nullable(Box::new(Type::String)))],
            return_types: vec![Box::new(Type::Number)],
        };

        // This SHOULD work - more general function can substitute for more specific one
        assert_eq!(true, nullable_param.is_assignable_to(&non_nullable_param));
    }

    #[test]
    fn test_function_assignability_with_nullable_returns() {
        // Function with non-nullable return
        let non_nullable_return = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        };

        // Function with nullable return
        let nullable_return = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Nullable(Box::new(Type::String)))],
        };

        assert!(non_nullable_return.is_assignable_to(&nullable_return));
        assert!(!nullable_return.is_assignable_to(&non_nullable_return));
    }

    #[test]
    fn test_void_functions() {
        // Void function (no return values)
        let void_func = Type::Function {
            params: vec![Box::new(Type::String)],
            return_types: vec![],
        };

        // Another void function with same parameters
        let another_void_func = Type::Function {
            params: vec![Box::new(Type::String)],
            return_types: vec![],
        };

        // Should be assignable
        assert!(void_func.is_assignable_to(&another_void_func));

        // Void function with different parameters
        let different_void_func = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![],
        };

        assert!(!void_func.is_assignable_to(&different_void_func));
    }

    #[test]
    fn test_complex_nested_function_types() {
        // Function that takes a function as parameter
        let higher_order_func = Type::Function {
            params: vec![Box::new(Type::Function {
                params: vec![Box::new(Type::Number)],
                return_types: vec![Box::new(Type::String)],
            })],
            return_types: vec![Box::new(Type::Bool)],
        };

        // Same higher-order function
        let same_higher_order = Type::Function {
            params: vec![Box::new(Type::Function {
                params: vec![Box::new(Type::Number)],
                return_types: vec![Box::new(Type::String)],
            })],
            return_types: vec![Box::new(Type::Bool)],
        };

        assert!(higher_order_func.is_assignable_to(&same_higher_order));

        // Different inner function signature
        let different_inner = Type::Function {
            params: vec![Box::new(Type::Function {
                params: vec![Box::new(Type::String)],
                return_types: vec![Box::new(Type::String)],
            })],
            return_types: vec![Box::new(Type::Bool)],
        };

        assert!(!higher_order_func.is_assignable_to(&different_inner));
    }

    // Helper to reset registry for each test
    fn setup_registry() {
        let mut registry = CLASS_REGISTRY.write().unwrap();
        registry.clear();

        registry.insert(
            "Animal".to_string(),
            ClassInfo {
                name: "Animal".to_string(),
                superclass: None,
            },
        );
        registry.insert(
            "Dog".to_string(),
            ClassInfo {
                name: "Dog".to_string(),
                superclass: Some("Animal".to_string()),
            },
        );
        registry.insert(
            "Cat".to_string(),
            ClassInfo {
                name: "Cat".to_string(),
                superclass: Some("Animal".to_string()),
            },
        );
        registry.insert(
            "Poodle".to_string(),
            ClassInfo {
                name: "Poodle".to_string(),
                superclass: Some("Dog".to_string()),
            },
        );
    }

    #[test]
    fn test_class_exact_match() {
        setup_registry();
        let a = Type::Class("Dog".to_string());
        let b = Type::Class("Dog".to_string());

        assert!(a.is_assignable_to(&b));
    }

    #[test]
    fn test_class_subtype() {
        setup_registry();
        let poodle = Type::Class("Poodle".to_string());
        let dog = Type::Class("Dog".to_string());
        let animal = Type::Class("Animal".to_string());

        assert!(poodle.is_assignable_to(&dog));
        assert!(poodle.is_assignable_to(&animal));
    }

    #[test]
    fn test_class_supertype_not_assignable_to_subtype() {
        setup_registry();
        let dog = Type::Class("Dog".to_string());
        let poodle = Type::Class("Poodle".to_string());

        assert!(!dog.is_assignable_to(&poodle));
    }

    #[test]
    fn test_class_unregistered() {
        setup_registry();
        let unknown = Type::Class("Dragon".to_string());
        let animal = Type::Class("Animal".to_string());

        // Unregistered class should not be assignable to anything
        assert!(!unknown.is_assignable_to(&animal));
    }
}


// ===== End of src/types.rs =====

// ===== File: src/value.rs =====

use std::{cell::RefCell, rc::Rc};

use crate::object::HeapObject;

pub enum Value {
    Number(f64),
    Bool(bool),
    Nil,
    Object(Rc<RefCell<HeapObject>>),
}


// ===== End of src/value.rs =====

