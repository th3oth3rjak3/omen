// THIS IS AUTOGENERATED TO ASSIST WITH AI CONTEXT. DO NOT EDIT.

// ===== File: src/ast.rs =====

use crate::types::Type;

#[derive(Debug, Clone, PartialEq)]
pub struct Program {
    pub statements: Vec<Statement>,
}

impl Default for Program {
    fn default() -> Self {
        Self {
            statements: Default::default(),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct FunctionDecl {
    pub name: String,
    pub params: Vec<Parameter>,
    pub return_type: Option<Type>,
    pub body: Block,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Parameter {
    pub name: String,
    pub param_type: Type,
}

impl Parameter {
    pub fn new(name: String, param_type: Type) -> Self {
        Self { name, param_type }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct ClassDecl {
    pub name: String,
    pub body: Vec<ClassItem>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ClassItem {
    Field { name: String, field_type: String },
    Method(FunctionDecl),
}

#[derive(Debug, Clone, PartialEq)]
pub struct Block {
    pub statements: Vec<Statement>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Statement {
    VarDeclaration {
        name: String,
        type_annotation: Type,
        initializer: Expression,
    },
    Assignment {
        name: String,
        value: Expression,
    },
    ExpressionStatement(Expression),
    Print(Expression),
    If {
        condition: Expression,
        then_branch: Box<Statement>,
        else_branch: Option<Box<Statement>>,
    },
    Block(Vec<Statement>),
    While {
        condition: Expression,
        body: Box<Statement>,
    },
    FunctionDeclaration {
        name: String,
        parameters: Vec<Parameter>,
        return_type: Option<Type>,
        body: Box<Statement>,
    },
    Return(Option<Expression>),
}

#[derive(Debug, Clone, PartialEq, Copy)]
pub enum UnaryOperator {
    Negate,
    Not,
}

#[derive(Debug, Clone, PartialEq, Copy)]
pub enum BinaryOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Equal,
    NotEqual,
    LogicalAnd,
    LogicalOr,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Expression {
    Number(f64),
    Bool(bool),
    String(String),
    Identifier(String),
    Unary {
        operator: UnaryOperator,
        operand: Box<Expression>,
    },
    Binary {
        left: Box<Expression>,
        operator: BinaryOperator,
        right: Box<Expression>,
    },
    Nil,
    Call {
        name: String,
        arguments: Vec<Expression>,
    },
}


// ===== End of src/ast.rs =====

// ===== File: src/error_handling.rs =====

#[derive(Debug, Clone, Copy)]
pub struct Position {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
}

impl Default for Position {
    fn default() -> Self {
        Self {
            line: 1,
            column: 0,
            offset: 0,
        }
    }
}

impl Position {
    pub fn new(line: usize, column: usize, offset: usize) -> Self {
        Self {
            line,
            column,
            offset,
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub struct Span {
    pub start: Position,
    pub end: Option<Position>,
}

impl Default for Span {
    fn default() -> Self {
        Self {
            start: Default::default(),
            end: None,
        }
    }
}

impl Span {
    pub fn new(start: Position, end: Option<Position>) -> Self {
        Self { start, end }
    }
}


// ===== End of src/error_handling.rs =====

// ===== File: src/heap.rs =====

use std::{cell::RefCell, rc::Rc};

use crate::object::{HeapObject, Object};

/// Heap is the memory heap for allocating and deallocating memory
/// that is tracked by the runtime.
#[derive(Debug, Clone)]
pub struct Heap {
    /// An intrusive linked list tracks all of the
    /// allocated objects on the heap.
    objects: Option<Rc<RefCell<HeapObject>>>,
    /// The number of bytes allocated since the last GC.
    allocated_bytes_since_last_gc: usize,
    /// The number of bytes, that when exceeded, triggers a garbage collection cycle.
    gc_threshold_bytes: usize,
}

impl Heap {
    /// Create a new heap.
    ///
    /// # Parameters
    /// * `initial_threshold` - The size in bytes until the first GC.
    pub fn new(initial_threshold: usize) -> Self {
        Self {
            objects: None,
            allocated_bytes_since_last_gc: 0,
            gc_threshold_bytes: initial_threshold,
        }
    }

    /// Create a new heap-managed allocation.
    ///
    /// # Params:
    /// * `object` - The object to place on the heap.
    ///
    /// # Returns:
    /// * The allocated object, now tracked by the heap.
    pub fn allocate(&mut self, object: Object) -> Rc<RefCell<HeapObject>> {
        let heap_obj = HeapObject::new(object, self.objects.take());
        let new_alloc = Rc::new(RefCell::new(heap_obj));
        self.objects = Some(new_alloc.clone());

        self.allocated_bytes_since_last_gc += new_alloc.borrow().size();

        new_alloc
    }

    /// Determine if garbage collection is needed.
    ///
    /// # Returns:
    /// * True when the allocations have exceeded the threshold, otherwise false.
    pub fn needs_collection(&self) -> bool {
        self.allocated_bytes_since_last_gc >= self.gc_threshold_bytes
    }

    /// Lets the heap know that now is a safe time to run a garbage collection.
    ///
    /// # Parameters
    /// * `roots` - A slice of `Rc<RefCell<HeapObject>>` representing all currently
    ///   reachable objects from the VM (e.g., stack values, globals, and other
    ///   root references). The GC will start marking from these objects to
    ///   determine which objects are still alive.
    pub fn collect_garbage(&mut self, roots: &[Rc<RefCell<HeapObject>>]) {
        self.mark(roots);
        self.sweep();
    }

    /// Mark all of the objects that are reachable from the provided roots
    /// to prepare for a garbage collection. Any marked items are spared from collection.
    ///
    /// # Params
    /// * `roots` - A slice of `Rc<RefCell<HeapObject>>` representing all currently
    ///   reachable objects from the VM (e.g., stack values, globals, and other
    ///   root references). The GC will start marking from these objects to
    ///   determine which objects are still alive.
    fn mark(&mut self, roots: &[Rc<RefCell<HeapObject>>]) {
        let mut gray_stack: Vec<Rc<RefCell<HeapObject>>> = roots.to_vec();

        while let Some(obj_rc) = gray_stack.pop() {
            let mut obj = obj_rc.borrow_mut();
            if obj.marked {
                continue;
            }

            obj.marked = true;

            // add child references to gray stack
            for child in obj.children() {
                gray_stack.push(child.clone());
            }
        }
    }

    /// Remove all unmarked objects from the list and relink the list.
    /// When unmarked objects are removed from the list, if no other references
    /// exist to that object, the object will be freed.
    pub fn sweep(&mut self) {
        let mut new_head: Option<Rc<RefCell<HeapObject>>> = None;
        let mut last: Option<Rc<RefCell<HeapObject>>> = None;

        let mut current = self.objects.take();
        let mut reclaimed_bytes = 0;

        while let Some(obj_rc) = current {
            let mut obj = obj_rc.borrow_mut();
            let next = obj.next.take();

            if obj.marked {
                obj.marked = false;

                if let Some(last_rc) = &last {
                    last_rc.borrow_mut().next = Some(obj_rc.clone());
                } else {
                    new_head = Some(obj_rc.clone());
                }

                last = Some(obj_rc.clone());
            } else {
                // If the object isn't marked, we let it drop.
                reclaimed_bytes += obj.size();
            }

            current = next;
        }

        self.objects = new_head;

        // Reset allocation counter
        let allocated_since_last_gc = self.allocated_bytes_since_last_gc;
        self.allocated_bytes_since_last_gc = 0;

        // Adaptive threshold: increase if little reclaimed, decrease if lots freed
        let freed_fraction = reclaimed_bytes as f64 / (allocated_since_last_gc.max(1) as f64);
        if freed_fraction < 0.1 {
            self.gc_threshold_bytes = (self.gc_threshold_bytes as f64 * 1.5) as usize;
        } else {
            // Avoid shrinking too much
            const MIN_THRESHOLD: usize = 1024;
            self.gc_threshold_bytes = std::cmp::max(
                MIN_THRESHOLD,
                (self.gc_threshold_bytes as f64 * 0.8) as usize,
            );
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn unreferenced_objects_are_collected() {
        let mut heap = Heap::new(1024);

        // Allocate three objects, none of which are roots
        heap.allocate(Object::String("one".into()));
        heap.allocate(Object::String("two".into()));
        heap.allocate(Object::String("three".into()));

        // Before GC, the heap has 3 objects
        assert!(heap.objects.is_some());

        // Run GC with no roots
        heap.collect_garbage(&[]);

        // After GC, the list should be empty
        assert!(heap.objects.is_none());
    }

    #[test]
    fn referenced_objects_are_preserved() {
        let mut heap = Heap::new(1024);

        // Allocate some objects
        let obj1 = heap.allocate(Object::String("one".into()));
        let _ = heap.allocate(Object::String("two".into()));

        // Only obj1 is a root
        let roots = vec![obj1.clone()];

        // Run GC
        heap.collect_garbage(&roots);

        // obj1 should still be alive
        assert!(heap.objects.is_some());
        assert!(
            heap.objects.as_ref().unwrap().borrow().marked == false
                || heap.objects.as_ref().unwrap().borrow().object == Object::String("one".into())
        );

        // obj2 should be collected
        // Note: since we don't have direct access to obj2, we just check count
        // We could traverse the list and count elements if needed
        let mut count = 0;
        let mut current = heap.objects.clone();
        while let Some(rc) = current {
            count += 1;
            current = rc.borrow().next.clone();
        }
        assert_eq!(count, 1);
    }
}


// ===== End of src/heap.rs =====

// ===== File: src/keywords.rs =====

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Keyword {
    If,
    Else,
    Class,
    Return,
    Continue,
    Break,
    Let,
    Nil,
    While,
    For,
    Function,
    This,
    Super,
    True,
    False,
    And,
    Or,
    Print,
}

impl TryFrom<&str> for Keyword {
    type Error = String;

    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "if" => Ok(Keyword::If),
            "else" => Ok(Keyword::Else),
            "class" => Ok(Keyword::Class),
            "return" => Ok(Keyword::Return),
            "continue" => Ok(Keyword::Continue),
            "break" => Ok(Keyword::Break),
            "let" => Ok(Keyword::Let),
            "nil" => Ok(Keyword::Nil),
            "while" => Ok(Keyword::While),
            "for" => Ok(Keyword::For),
            "fn" => Ok(Keyword::Function),
            "this" => Ok(Keyword::This),
            "super" => Ok(Keyword::Super),
            "true" => Ok(Keyword::True),
            "false" => Ok(Keyword::False),
            "and" => Ok(Keyword::And),
            "or" => Ok(Keyword::Or),
            "print" => Ok(Keyword::Print),
            _ => Err(format!("{value} is not a keyword")),
        }
    }
}


// ===== End of src/keywords.rs =====

// ===== File: src/lexer.rs =====

use crate::{
    error_handling::{Position, Span},
    keywords::Keyword,
    tokens::{Delimiter, Operator, Special, Token, TokenKind},
};

#[derive(Debug, Clone)]
pub struct Lexer {
    pub source: Vec<char>,
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub line_offset: usize,
}

impl Default for Lexer {
    fn default() -> Self {
        Self {
            source: Vec::new(),
            line: 1,
            column: 0,
            offset: 0,
            line_offset: 0,
        }
    }
}

impl Lexer {
    pub fn tokenize(&mut self) -> Vec<Token> {
        let mut tokens = Vec::new();

        loop {
            let tok = self.next_token();
            let kind = tok.kind.clone();
            tokens.push(tok);

            if kind.is_special(Special::Eof) {
                return tokens;
            }
        }
    }

    fn next_token(&mut self) -> Token {
        self.skip_whitespace_and_comments();

        let current = self.peek();
        if current == '\0' {
            return Token::new(
                TokenKind::Special(Special::Eof),
                Span::new(self.position(), None),
            );
        }

        if current.is_ascii_alphabetic() || current == '_' {
            return self.handle_identifier();
        }

        if current.is_ascii_digit() {
            return self.handle_numbers();
        }

        if current == '"' {
            return self.handle_string_literal();
        }

        match current {
            // delimiters
            '(' => self.make_single(TokenKind::Delimiter(Delimiter::LeftParen)),
            ')' => self.make_single(TokenKind::Delimiter(Delimiter::RightParen)),
            '[' => self.make_single(TokenKind::Delimiter(Delimiter::LeftBracket)),
            ']' => self.make_single(TokenKind::Delimiter(Delimiter::RightBracket)),
            '{' => self.make_single(TokenKind::Delimiter(Delimiter::LeftBrace)),
            '}' => self.make_single(TokenKind::Delimiter(Delimiter::RightBrace)),
            ':' => self.make_single(TokenKind::Delimiter(Delimiter::Colon)),
            ';' => self.make_single(TokenKind::Delimiter(Delimiter::Semicolon)),
            ',' => self.make_single(TokenKind::Delimiter(Delimiter::Comma)),

            // operators
            '+' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::PlusEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Plus)),
            },
            '-' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::MinusEqual)),
                '>' => self.make_double(TokenKind::Operator(Operator::Arrow)),
                _ => self.make_single(TokenKind::Operator(Operator::Minus)),
            },
            '*' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::StarEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Star)),
            },
            '/' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::SlashEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Slash)),
            },
            '=' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::EqualEqual)),
                '>' => self.make_double(TokenKind::Operator(Operator::FatArrow)),
                _ => self.make_single(TokenKind::Operator(Operator::Equal)),
            },
            '!' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::BangEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Bang)),
            },
            '<' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::LessEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Less)),
            },
            '>' => match self.peek_next() {
                '=' => self.make_double(TokenKind::Operator(Operator::GreaterEqual)),
                _ => self.make_single(TokenKind::Operator(Operator::Greater)),
            },
            '.' => self.make_single(TokenKind::Operator(Operator::Dot)),
            '?' => self.make_single(TokenKind::Operator(Operator::Question)),
            _ => self.make_error_token(format!("Unexpected character '{current}'")),
        }
    }

    fn handle_identifier(&mut self) -> Token {
        let start = self.position();
        self.advance(); // skip the first char which is a valid alpha or _ char
        while !self.is_at_end() && (self.peek().is_ascii_alphanumeric() || self.peek() == '_') {
            self.advance();
        }

        let span = Span::new(start, Some(self.position()));

        let literal = self.source[start.offset..self.offset]
            .to_vec()
            .iter()
            .collect::<String>();

        let kw = Keyword::try_from(literal.as_ref());
        if let Ok(kw) = kw {
            return Token::new(TokenKind::Keyword(kw), span);
        }

        Token::new(TokenKind::Identifier(literal), span)
    }

    fn handle_numbers(&mut self) -> Token {
        let start = self.position();
        self.advance(); // skip the first number that we already checked.
        while !self.is_at_end() && self.peek().is_ascii_digit() {
            self.advance();
        }

        if self.peek() == '.' && self.peek_next().is_ascii_digit() {
            self.advance(); // skip over period
            while !self.is_at_end() && self.peek().is_ascii_digit() {
                self.advance();
            }
        }

        let span = Span::new(start, Some(self.position()));
        let literal: String = self.source[start.offset..self.offset].iter().collect();
        Token::new(TokenKind::Number(literal), span)
    }

    fn handle_string_literal(&mut self) -> Token {
        self.advance(); // skip "
        let start = self.position();

        while !self.is_at_end() && self.peek() != '"' {
            self.advance();
        }

        if self.peek() != '"' {
            return self.make_error_token("unterminated string literal".into());
        }

        let end = self.position();
        let span = Span::new(start, Some(end));
        let literal = self.source[start.offset..end.offset]
            .iter()
            .collect::<String>();

        let tok = Token::new(TokenKind::String(literal), span);

        self.advance(); // advance over the " for the next token
        return tok;
    }

    fn position(&mut self) -> Position {
        Position::new(self.line, self.column, self.offset)
    }

    fn is_at_end(&mut self) -> bool {
        self.offset >= self.source.len()
    }

    fn advance(&mut self) {
        match self.peek() {
            '\n' => {
                self.offset += 1;
                self.line += 1;
                self.column = 0;
                self.line_offset = self.offset;
            }
            '\0' => return,
            _ => {
                self.offset += 1;
                self.column += 1;
            }
        }
    }

    fn peek(&mut self) -> char {
        self.peek_at(self.offset)
    }

    fn peek_next(&mut self) -> char {
        self.peek_at(self.offset + 1)
    }

    fn peek_at(&mut self, offset: usize) -> char {
        if offset >= self.source.len() {
            return '\0';
        }

        return self.source[offset];
    }

    fn make_error_token(&mut self, err: String) -> Token {
        let start = self.position();
        self.advance();
        let span = Span::new(start, None);
        Token::new(TokenKind::Special(Special::Error(err)), span)
    }

    fn make_single(&mut self, kind: TokenKind) -> Token {
        let start = self.position();
        self.advance();
        let end = Some(self.position());
        let span = Span::new(start, end);
        Token::new(kind, span)
    }

    fn make_double(&mut self, kind: TokenKind) -> Token {
        let start = self.position();
        self.advance();
        self.advance();
        let end = Some(self.position());
        let span = Span::new(start, end);
        Token::new(kind, span)
    }

    fn skip_whitespace(&mut self) {
        loop {
            match self.peek() {
                '\r' | '\t' | '\n' | ' ' => self.advance(),
                _ => return,
            }
        }
    }

    fn skip_comments(&mut self) {
        while self.peek() != '\n' {
            self.advance();
        }
    }

    fn skip_whitespace_and_comments(&mut self) {
        loop {
            self.skip_whitespace();
            match (self.peek(), self.peek_next()) {
                ('/', '/') => self.skip_comments(),
                _ => return,
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::{keywords::Keyword, tokens::Operator};

    use super::*;

    #[test]
    pub fn lexer_can_tokenize_all_delimiters() {
        let source = "()[]{}:;,";
        let mut lexer = Lexer::default();
        lexer.source = source.chars().collect();

        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));

        assert!(tokens[0].kind.is_delimiter(Delimiter::LeftParen));
        assert!(tokens[1].kind.is_delimiter(Delimiter::RightParen));
        assert!(tokens[2].kind.is_delimiter(Delimiter::LeftBracket));
        assert!(tokens[3].kind.is_delimiter(Delimiter::RightBracket));
        assert!(tokens[4].kind.is_delimiter(Delimiter::LeftBrace));
        assert!(tokens[5].kind.is_delimiter(Delimiter::RightBrace));
        assert!(tokens[6].kind.is_delimiter(Delimiter::Colon));
        assert!(tokens[7].kind.is_delimiter(Delimiter::Semicolon));
        assert!(tokens[8].kind.is_delimiter(Delimiter::Comma));
    }

    #[test]
    pub fn lexer_can_tokenize_all_keywords() {
        let source = r#"
            if 
            else 
            class 
            return 
            continue 
            break 
            let 
            nil 
            while 
            for 
            fn 
            this 
            super
            true
            false    
        "#;

        let mut lexer = Lexer::default();
        lexer.source = source.chars().collect();

        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));

        assert!(tokens[0].kind.is_keyword(Keyword::If));
        assert!(tokens[1].kind.is_keyword(Keyword::Else));
        assert!(tokens[2].kind.is_keyword(Keyword::Class));
        assert!(tokens[3].kind.is_keyword(Keyword::Return));
        assert!(tokens[4].kind.is_keyword(Keyword::Continue));
        assert!(tokens[5].kind.is_keyword(Keyword::Break));
        assert!(tokens[6].kind.is_keyword(Keyword::Let));
        assert!(tokens[7].kind.is_keyword(Keyword::Nil));
        assert!(tokens[8].kind.is_keyword(Keyword::While));
        assert!(tokens[9].kind.is_keyword(Keyword::For));
        assert!(tokens[10].kind.is_keyword(Keyword::Function));
        assert!(tokens[11].kind.is_keyword(Keyword::This));
        assert!(tokens[12].kind.is_keyword(Keyword::Super));
        assert!(tokens[13].kind.is_keyword(Keyword::True));
        assert!(tokens[14].kind.is_keyword(Keyword::False));
    }

    #[test]
    pub fn lexer_can_tokenize_all_operators() {
        let source = "+ += - -= * *= / /= = == ! != < <= > >= . -> => ?";
        let mut lexer = Lexer::default();
        lexer.source = source.chars().collect();

        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));

        assert!(tokens[0].kind.is_operator(Operator::Plus));
        assert!(tokens[1].kind.is_operator(Operator::PlusEqual));
        assert!(tokens[2].kind.is_operator(Operator::Minus));
        assert!(tokens[3].kind.is_operator(Operator::MinusEqual));
        assert!(tokens[4].kind.is_operator(Operator::Star));
        assert!(tokens[5].kind.is_operator(Operator::StarEqual));
        assert!(tokens[6].kind.is_operator(Operator::Slash));
        assert!(tokens[7].kind.is_operator(Operator::SlashEqual));
        assert!(tokens[8].kind.is_operator(Operator::Equal));
        assert!(tokens[9].kind.is_operator(Operator::EqualEqual));
        assert!(tokens[10].kind.is_operator(Operator::Bang));
        assert!(tokens[11].kind.is_operator(Operator::BangEqual));
        assert!(tokens[12].kind.is_operator(Operator::Less));
        assert!(tokens[13].kind.is_operator(Operator::LessEqual));
        assert!(tokens[14].kind.is_operator(Operator::Greater));
        assert!(tokens[15].kind.is_operator(Operator::GreaterEqual));
        assert!(tokens[16].kind.is_operator(Operator::Dot));
        assert!(tokens[17].kind.is_operator(Operator::Arrow));
        assert!(tokens[18].kind.is_operator(Operator::FatArrow));
        assert!(tokens[19].kind.is_operator(Operator::Question));
    }

    #[test]
    pub fn lexer_can_produce_number_tokens() {
        let source = "1 1.2 1.0 432";
        let mut lexer = Lexer::default();
        lexer.source = source.chars().collect();
        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));

        assert_eq!(TokenKind::Number("1".into()), tokens[0].kind);
        assert_eq!(TokenKind::Number("1.2".into()), tokens[1].kind);
        assert_eq!(TokenKind::Number("1.0".into()), tokens[2].kind);
        assert_eq!(TokenKind::Number("432".into()), tokens[3].kind);
    }

    #[test]
    pub fn lexer_produces_eof_token_for_empty_input() {
        let mut lexer = Lexer::default();
        let tokens = lexer.tokenize();
        assert!(!tokens.is_empty() && tokens.last().unwrap().kind.is_special(Special::Eof));
    }

    #[test]
    pub fn lexer_handles_string_literals() {
        let mut lexer = Lexer::default();
        lexer.source = r#""a raw string""#.chars().collect();
        let tokens = lexer.tokenize();
        assert_eq!(2, tokens.len());
        assert_eq!(TokenKind::String("a raw string".into()), tokens[0].kind);
    }
}


// ===== End of src/lexer.rs =====

// ===== File: src/main.rs =====

pub mod ast;
pub mod error_handling;
pub mod heap;
pub mod keywords;
pub mod lexer;
pub mod object;
pub mod parser;
pub mod runtime;
pub mod tokens;
pub mod types;
pub mod value;

use clap::{Parser, Subcommand};
use std::fs;
use std::path::PathBuf;

use crate::types::type_check_program;

#[derive(Parser)]
#[command(name = "omen")]
#[command(about = "The Omen programming language interpreter")]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Run an Omen script file
    Run {
        /// Path to the .omen file to execute
        file: PathBuf,
    },
}

fn main() {
    let cli = Cli::parse();

    match cli.command {
        Commands::Run { file } => {
            if let Err(e) = run_file(file) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
        }
    }
}

fn run_file(file_path: PathBuf) -> Result<(), Box<dyn std::error::Error>> {
    // Check file extension
    if file_path.extension().unwrap_or_default() != "omen" {
        return Err("File must have .omen extension".into());
    }

    // Read the file
    let source = fs::read_to_string(&file_path)?;

    // Lex, parse, and interpret
    let mut lexer = crate::lexer::Lexer::default();
    lexer.source = source.chars().collect();

    let tokens = lexer.tokenize();
    let mut parser = crate::parser::Parser::new(tokens);
    let program = parser.parse();

    if let Err(type_error) = type_check_program(&program) {
        eprintln!("Type error: {}", type_error);
        std::process::exit(1);
    }

    let mut interpreter = crate::runtime::Interpreter::new();
    interpreter.interpret(&program)?;

    Ok(())
}


// ===== End of src/main.rs =====

// ===== File: src/object.rs =====

use std::{cell::RefCell, rc::Rc};

use crate::{
    ast::{Parameter, Statement},
    runtime::Environment,
    types::Type,
    value::Value,
};

#[derive(Debug, Clone, PartialEq)]
pub struct Function {
    pub name: String,
    pub parameters: Vec<Parameter>,
    pub return_type: Option<Type>,
    pub body: Statement,
    pub closure_env: Rc<RefCell<Environment>>, // Captured environment
}

/// Represents any reference type object that
/// is to be heap allocated
#[derive(Debug, Clone, PartialEq)]
pub enum Object {
    String(String),
    Function(Function),
}

/// HeapObject is a wrapper type that contains metadata about
/// an object for garbage collection and memory management.
#[derive(Debug, Clone, PartialEq)]
pub struct HeapObject {
    /// When true, the object was reachable from GC roots
    /// meaning that the object should not be collected.
    pub marked: bool,
    /// Next is the next object in the intrusive list. When None,
    /// we've reached the end.
    pub next: Option<Rc<RefCell<HeapObject>>>,
    /// Object is the actual object contents stored in the wrapper.
    pub object: Object,
}

impl HeapObject {
    pub fn new(object: Object, next: Option<Rc<RefCell<HeapObject>>>) -> Self {
        Self {
            marked: false,
            next,
            object,
        }
    }

    /// Get a slice of all child objects that this object references.
    ///
    /// # Returns
    /// * A slice of objects referenced by this object.
    pub fn children(&self) -> Vec<Rc<RefCell<HeapObject>>> {
        match &self.object {
            Object::String(_) => vec![],
            Object::Function(fun) => {
                // Return any heap objects referenced in the closure environment
                // This will need to walk the environment and collect heap object references
                self.collect_env_references(&fun.closure_env)
            }
        }
    }

    fn collect_env_references(
        &self,
        env: &Rc<RefCell<Environment>>,
    ) -> Vec<Rc<RefCell<HeapObject>>> {
        let mut refs = vec![];
        let env_borrow = env.borrow();
        for scope in &env_borrow.scopes {
            let borrow_scope = scope.borrow();
            for value in borrow_scope.values() {
                if let Value::Object(obj) = value {
                    refs.push(obj.clone());
                }
            }
        }
        refs
    }

    /// Get the heap size of the object.
    pub fn size(&self) -> usize {
        let self_size = std::mem::size_of::<Self>();
        let obj_size = match &self.object {
            Object::String(s) => s.capacity(),
            Object::Function(_) => std::mem::size_of::<Function>(),
        };

        self_size + obj_size
    }
}


// ===== End of src/object.rs =====

// ===== File: src/parser.rs =====

use crate::{
    ast::{BinaryOperator, Expression, Parameter, Program, Statement, UnaryOperator},
    error_handling::Span,
    keywords::Keyword,
    tokens::{Delimiter, Operator, Special, Token, TokenKind},
    types::Type,
};

#[derive(Debug, Clone)]
pub struct Parser {
    current: usize,
    tokens: Vec<Token>,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self { current: 0, tokens }
    }

    pub fn parse(&mut self) -> Program {
        let mut program = Program::default();

        while !self.is_at_end() {
            let stmt = self.parse_statement();
            program.statements.push(stmt);
        }

        program
    }

    fn parse_statement(&mut self) -> Statement {
        match &self.peek().kind {
            TokenKind::Delimiter(Delimiter::LeftBrace) => self.parse_block_statement(),
            TokenKind::Keyword(Keyword::Let) => self.parse_var_declaration(),
            TokenKind::Keyword(Keyword::Print) => self.parse_print_statement(),
            TokenKind::Keyword(Keyword::If) => self.parse_if_statement(),
            TokenKind::Keyword(Keyword::While) => self.parse_while_statement(),
            TokenKind::Keyword(Keyword::Function) => self.parse_function_declaration(),
            TokenKind::Keyword(Keyword::Return) => self.parse_return_statement(),
            TokenKind::Identifier(ident) if self.peek_next().kind.is_operator(Operator::Equal) => {
                self.parse_assignment(ident.to_owned())
            }
            _ => {
                // Default to expression statement
                let expr = self.parse_expression();
                self.consume_delimiter(Delimiter::Semicolon);
                Statement::ExpressionStatement(expr)
            }
        }
    }

    fn parse_type(&mut self) -> Type {
        let base_type = if let TokenKind::Identifier(type_name) = &self.peek().kind {
            let name = type_name.as_str();
            self.advance();

            match name {
                "Number" => Type::Number,
                "Bool" => Type::Bool,
                "String" => Type::String,
                "Nil" => panic!("Cannot declare variables of type Nil"),
                _ => Type::Class(type_name.clone()),
            }
        } else {
            panic!("Expected type name");
        };

        // Check for optional `?` suffix
        if self.peek().kind.is_operator(Operator::Question) {
            self.advance(); // consume '?'
            Type::Nullable(Box::new(base_type))
        } else {
            base_type
        }
    }

    fn parse_var_declaration(&mut self) -> Statement {
        self.advance(); // consume 'let'

        // Parse variable name
        let name = if let TokenKind::Identifier(id) = &self.peek().kind {
            let n = id.clone();
            self.advance();
            n
        } else {
            panic!("Expected identifier after 'let'");
        };

        // Require colon
        if !self.peek().kind.is_delimiter(Delimiter::Colon) {
            panic!("Expected ':' after variable name");
        }
        self.advance(); // consume ':'

        // Parse type annotation (required)
        let type_annotation = self.parse_type();

        // Require equals sign
        if !self.peek().kind.is_operator(Operator::Equal) {
            panic!("Variable must be initialized - no default values allowed");
        }
        self.advance(); // consume '='

        // Parse initializer expression
        let initializer = self.parse_expression();

        // Consume semicolon
        self.consume_delimiter(Delimiter::Semicolon);

        Statement::VarDeclaration {
            name,
            type_annotation,
            initializer,
        }
    }

    fn parse_print_statement(&mut self) -> Statement {
        self.advance(); // consume 'print'
        let expr = self.parse_expression();
        self.consume_delimiter(Delimiter::Semicolon);
        Statement::Print(expr)
    }

    fn parse_return_statement(&mut self) -> Statement {
        self.advance(); // consume 'return';
        let mut return_expr: Option<Expression> = None;

        if self.peek().kind.is_delimiter(Delimiter::Semicolon) {
        } else {
            let expr = self.parse_expression();
            return_expr = Some(expr);
        }

        self.consume_delimiter(Delimiter::Semicolon);
        Statement::Return(return_expr)
    }

    fn parse_assignment(&mut self, ident: String) -> Statement {
        self.advance(); // skip over the name
        self.advance(); // skip over the =
        let expr = self.parse_expression();
        self.consume_delimiter(Delimiter::Semicolon);

        Statement::Assignment {
            name: ident,
            value: expr,
        }
    }

    fn parse_if_statement(&mut self) -> Statement {
        self.advance(); // consume 'if'
        let condition = self.parse_expression();
        let then_branch = Box::new(self.parse_statement());

        let else_branch = if self.peek().kind.is_keyword(Keyword::Else) {
            self.advance(); // consume 'else'
            Some(Box::new(self.parse_statement()))
        } else {
            None
        };

        Statement::If {
            condition,
            then_branch,
            else_branch,
        }
    }

    fn parse_while_statement(&mut self) -> Statement {
        self.advance(); // consume 'while'
        let condition = self.parse_expression();
        let body = Box::new(self.parse_statement());
        Statement::While { condition, body }
    }

    fn parse_block_statement(&mut self) -> Statement {
        self.consume_delimiter(Delimiter::LeftBrace);
        let mut statements = Vec::new();

        while !self.peek().kind.is_delimiter(Delimiter::RightBrace) && !self.is_at_end() {
            statements.push(self.parse_statement());
        }

        self.consume_delimiter(Delimiter::RightBrace);
        Statement::Block(statements)
    }

    fn parse_function_declaration(&mut self) -> Statement {
        self.advance(); // consume 'fn'

        let name = if let TokenKind::Identifier(id) = &self.peek().kind {
            let n = id.clone();
            self.advance();
            n
        } else {
            panic!("Expected function name");
        };

        self.consume_delimiter(Delimiter::LeftParen);

        let mut parameters: Vec<Parameter> = Vec::new();
        while !self.peek().kind.is_delimiter(Delimiter::RightParen) {
            let param_name = if let TokenKind::Identifier(id) = &self.peek().kind {
                let n = id.clone();
                self.advance();
                n
            } else {
                panic!("Expected parameter name");
            };

            self.consume_delimiter(Delimiter::Colon);
            let param_type = self.parse_type();

            parameters.push(Parameter::new(param_name, param_type));

            if self.peek().kind.is_delimiter(Delimiter::Comma) {
                self.advance(); // consume comma
            }
        }

        self.consume_delimiter(Delimiter::RightParen);

        let return_type = if self.peek().kind.is_operator(Operator::Arrow) {
            self.advance();
            Some(self.parse_type())
        } else {
            None
        };

        let body = Box::new(self.parse_statement()); // Usually a block

        Statement::FunctionDeclaration {
            name,
            parameters,
            return_type,
            body,
        }
    }

    fn parse_expression(&mut self) -> Expression {
        self.parse_logical_or()
    }

    fn parse_logical_or(&mut self) -> Expression {
        let mut expr = self.parse_logical_and();

        while self.peek().kind.is_keyword(Keyword::Or) {
            self.advance();
            let right = self.parse_logical_and();
            expr = Expression::Binary {
                left: Box::new(expr),
                operator: BinaryOperator::LogicalOr,
                right: Box::new(right),
            };
        }

        expr
    }

    fn parse_logical_and(&mut self) -> Expression {
        let mut expr = self.parse_equality();

        while self.peek().kind.is_keyword(Keyword::And) {
            self.advance();
            let right = self.parse_equality();
            expr = Expression::Binary {
                left: Box::new(expr),
                operator: BinaryOperator::LogicalAnd,
                right: Box::new(right),
            };
        }

        expr
    }

    fn parse_equality(&mut self) -> Expression {
        let mut expr = self.parse_comparison(); // left operand.
        while let TokenKind::Operator(op) = self.peek().kind {
            match op {
                Operator::EqualEqual => {
                    self.advance(); // consume '=='
                    let right = self.parse_comparison(); // Get right operand
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Equal,
                        right: Box::new(right),
                    };
                }
                Operator::BangEqual => {
                    self.advance(); // consume '!='
                    let right = self.parse_comparison();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::NotEqual,
                        right: Box::new(right),
                    };
                }
                _ => break, // Not a comparison operator
            }
        }

        expr
    }

    fn parse_comparison(&mut self) -> Expression {
        let mut expr = self.parse_term(); // Get left operand

        while let TokenKind::Operator(op) = self.peek().kind {
            match op {
                Operator::Less => {
                    self.advance(); // consume '<'
                    let right = self.parse_term(); // Get right operand
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Less,
                        right: Box::new(right),
                    };
                }
                Operator::LessEqual => {
                    self.advance(); // consume '<='
                    let right = self.parse_term();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::LessEqual,
                        right: Box::new(right),
                    };
                }
                Operator::Greater => {
                    self.advance(); // consume '>'
                    let right = self.parse_term();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Greater,
                        right: Box::new(right),
                    };
                }
                Operator::GreaterEqual => {
                    self.advance(); // consume '>='
                    let right = self.parse_term();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::GreaterEqual,
                        right: Box::new(right),
                    };
                }
                _ => break, // Not a comparison operator
            }
        }

        expr
    }

    fn parse_term(&mut self) -> Expression {
        let mut expr = self.parse_factor(); // Get left operand

        while let TokenKind::Operator(op) = self.peek().kind {
            match op {
                Operator::Plus => {
                    self.advance(); // consume '+'
                    let right = self.parse_factor(); // Get right operand
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Add,
                        right: Box::new(right),
                    };
                }
                Operator::Minus => {
                    self.advance(); // consume '-'
                    let right = self.parse_factor();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Subtract,
                        right: Box::new(right),
                    };
                }
                _ => break, // Not a term-level operator
            }
        }

        expr
    }

    fn parse_factor(&mut self) -> Expression {
        let mut expr = self.parse_unary(); // Get left operand

        while let TokenKind::Operator(op) = self.peek().kind {
            match op {
                Operator::Star => {
                    self.advance(); // consume '*'
                    let right = self.parse_unary(); // Get right operand
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Multiply,
                        right: Box::new(right),
                    };
                }
                Operator::Slash => {
                    self.advance(); // consume '/'
                    let right = self.parse_unary();
                    expr = Expression::Binary {
                        left: Box::new(expr),
                        operator: BinaryOperator::Divide,
                        right: Box::new(right),
                    };
                }
                _ => break, // Not a factor-level operator
            }
        }

        expr
    }

    fn parse_unary(&mut self) -> Expression {
        let kind = self.peek().kind;

        if kind.is_operator(Operator::Bang) {
            self.advance();
            let expr = self.parse_unary();
            return Expression::Unary {
                operator: UnaryOperator::Not,
                operand: Box::new(expr),
            };
        } else if kind.is_operator(Operator::Minus) {
            self.advance();
            let expr = self.parse_unary();
            return Expression::Unary {
                operator: UnaryOperator::Negate,
                operand: Box::new(expr),
            };
        } else {
            self.parse_primary()
        }
    }

    fn parse_primary(&mut self) -> Expression {
        let kind = self.peek().kind;
        match kind {
            TokenKind::Number(literal) => self.handle_number_literal(literal),
            TokenKind::String(literal) => self.handle_string_literal(literal),
            TokenKind::Keyword(Keyword::True) | TokenKind::Keyword(Keyword::False) => {
                self.handle_boolean_literal()
            }
            TokenKind::Keyword(Keyword::Nil) => self.handle_nil_literal(),
            TokenKind::Identifier(name) => self.handle_identifier(name),
            TokenKind::Delimiter(Delimiter::LeftParen) => self.handle_grouped_expression(),
            _ => Expression::Nil,
        }
    }

    fn handle_identifier(&mut self, name: String) -> Expression {
        let identifier = name.clone();
        self.advance();

        if self.peek().kind.is_delimiter(Delimiter::LeftParen) {
            // Function call
            self.advance(); // consume '('
            let mut arguments = Vec::new();

            while !self.peek().kind.is_delimiter(Delimiter::RightParen) {
                arguments.push(self.parse_expression());
                if self.peek().kind.is_delimiter(Delimiter::Comma) {
                    self.advance();
                }
            }

            self.consume_delimiter(Delimiter::RightParen);
            Expression::Call {
                name: identifier,
                arguments,
            }
        } else {
            // Variable reference
            Expression::Identifier(identifier)
        }
    }

    fn handle_number_literal(&mut self, literal: String) -> Expression {
        let result = literal.parse::<f64>();
        if let Err(e) = result {
            panic!("ERROR PARSING NUMBER LITERAL: {e}");
        }

        self.advance();
        Expression::Number(result.unwrap())
    }

    fn handle_string_literal(&mut self, literal: String) -> Expression {
        self.advance();
        Expression::String(literal)
    }

    fn handle_boolean_literal(&mut self) -> Expression {
        let kind = self.peek().kind;

        let expr = if kind.is_keyword(Keyword::True) {
            Expression::Bool(true)
        } else if kind.is_keyword(Keyword::False) {
            Expression::Bool(false)
        } else {
            unreachable!()
        };

        self.advance();
        expr
    }

    fn handle_nil_literal(&mut self) -> Expression {
        self.advance();
        Expression::Nil
    }

    fn handle_grouped_expression(&mut self) -> Expression {
        self.consume_delimiter(Delimiter::LeftParen);
        let expr = self.parse_expression();
        self.consume_delimiter(Delimiter::RightParen);

        expr
    }

    fn advance(&mut self) {
        if self.is_at_end() {
            return;
        }

        self.current += 1;
    }

    fn consume_delimiter(&mut self, expected: Delimiter) {
        let kind = self.peek().kind;
        let ok = match kind {
            TokenKind::Delimiter(actual) => actual == expected,
            _ => false,
        };

        self.advance();

        // TODO: add error handling to parser, we'll just panic instead.
        if !ok {
            panic!("Expected {:#?}, Got: {:#?}", expected, kind);
        }
    }

    fn peek(&self) -> Token {
        let default = Token::new(TokenKind::Special(Special::Eof), Span::default());
        self.tokens
            .get(self.current)
            .map(|thing| thing.to_owned())
            .unwrap_or_else(|| default)
    }

    fn peek_next(&self) -> Token {
        let default = Token::new(TokenKind::Special(Special::Eof), Span::default());
        self.tokens
            .get(self.current + 1)
            .map(|thing| thing.to_owned())
            .unwrap_or_else(|| default)
    }

    fn is_at_end(&self) -> bool {
        matches!(self.peek().kind, TokenKind::Special(Special::Eof))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{ast::UnaryOperator, lexer::Lexer, parser::Parser};

    #[test]
    pub fn parser_can_parse_simple_numbers() {
        let mut lexer = Lexer::default();
        lexer.source = "1.23;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Number(1.23))],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_simple_booleans() {
        let mut lexer = Lexer::default();
        lexer.source = "true;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();
        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Bool(true))],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_nil_literals() {
        let mut lexer = Lexer::default();
        lexer.source = "nil;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();
        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Nil)],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_basic_groupings() {
        let mut lexer = Lexer::default();
        lexer.source = "(true);".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Bool(true))],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_unary_logical_not_expressions() {
        let mut lexer = Lexer::default();
        lexer.source = "!true;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Unary {
                operator: UnaryOperator::Not,
                operand: Box::new(Expression::Bool(true)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_unary_negation_expressions() {
        let mut lexer = Lexer::default();
        lexer.source = "-5;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Unary {
                operator: UnaryOperator::Negate,
                operand: Box::new(Expression::Number(5.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_simple_binary_factor() {
        let mut lexer = Lexer::default();
        lexer.source = "1 * 2;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(1.)),
                operator: BinaryOperator::Multiply,
                right: Box::new(Expression::Number(2.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_simple_binary_term() {
        let mut lexer = Lexer::default();
        lexer.source = "1 - 2;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(1.)),
                operator: BinaryOperator::Subtract,
                right: Box::new(Expression::Number(2.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_simple_comparison() {
        let mut lexer = Lexer::default();
        lexer.source = "5 < 10;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(5.)),
                operator: BinaryOperator::Less,
                right: Box::new(Expression::Number(10.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_equality_when_equal() {
        let mut lexer = Lexer::default();
        lexer.source = "5 == 10;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(5.)),
                operator: BinaryOperator::Equal,
                right: Box::new(Expression::Number(10.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_equality_when_not_equal() {
        let mut lexer = Lexer::default();
        lexer.source = "5 != 10;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Number(5.)),
                operator: BinaryOperator::NotEqual,
                right: Box::new(Expression::Number(10.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_basic_identifiers() {
        let mut lexer = Lexer::default();
        lexer.source = "someIdent != 10;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Identifier("someIdent".into())),
                operator: BinaryOperator::NotEqual,
                right: Box::new(Expression::Number(10.)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_logical_and() {
        let mut lexer = Lexer::default();
        lexer.source = "true and false;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Bool(true)),
                operator: BinaryOperator::LogicalAnd,
                right: Box::new(Expression::Bool(false)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_logical_or() {
        let mut lexer = Lexer::default();
        lexer.source = "false or true;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::ExpressionStatement(Expression::Binary {
                left: Box::new(Expression::Bool(false)),
                operator: BinaryOperator::LogicalOr,
                right: Box::new(Expression::Bool(true)),
            })],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_let_with_number() {
        let mut lexer = Lexer::default();
        lexer.source = "let x: Number = 42;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "x".to_string(),
                type_annotation: Type::Number,
                initializer: Expression::Number(42.0),
            }],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_let_with_bool() {
        let mut lexer = Lexer::default();
        lexer.source = "let flag: Bool = true;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "flag".to_string(),
                type_annotation: Type::Bool,
                initializer: Expression::Bool(true),
            }],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_let_with_string() {
        let mut lexer = Lexer::default();
        lexer.source = r#"let name: String = "hello";"#.chars().collect();

        let tokens = lexer.tokenize();

        println!("{:#?}", tokens);

        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "name".to_string(),
                type_annotation: Type::String,
                initializer: Expression::String("hello".to_string()), // Assuming you add string literals
            }],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_let_with_expression_initializer() {
        let mut lexer = Lexer::default();
        lexer.source = "let result: Number = 5 + 3 * 2;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "result".to_string(),
                type_annotation: Type::Number,
                initializer: Expression::Binary {
                    left: Box::new(Expression::Number(5.0)),
                    operator: BinaryOperator::Add,
                    right: Box::new(Expression::Binary {
                        left: Box::new(Expression::Number(3.0)),
                        operator: BinaryOperator::Multiply,
                        right: Box::new(Expression::Number(2.0)),
                    }),
                },
            }],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    #[should_panic(expected = "Cannot declare variables of type Nil")]
    pub fn parser_rejects_nil_type_declaration() {
        let mut lexer = Lexer::default();
        lexer.source = "let invalid: Nil = nil;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        parser.parse(); // Should panic
    }

    #[test]
    pub fn parser_can_parse_let_with_nullable_type() {
        let mut lexer = Lexer::default();
        lexer.source = "let maybe: String? = nil;".chars().collect();

        let tokens = lexer.tokenize();
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        let expected = Program {
            statements: vec![Statement::VarDeclaration {
                name: "maybe".to_string(),
                type_annotation: Type::Nullable(Box::new(Type::String)),
                initializer: Expression::Nil,
            }],
        };

        assert_eq!(expected, ast);
    }

    #[test]
    pub fn parser_can_parse_assignment_statements() {
        let mut lexer = Lexer::default();
        lexer.source = "let x: Number = 1; x = 2;".chars().collect();

        let tokens = lexer.tokenize();
        println!("TOKENS: {:#?}", tokens);
        let mut parser = Parser::new(tokens);
        let ast = parser.parse();

        println!("AST: {:#?}", ast);

        let expected = Program {
            statements: vec![
                Statement::VarDeclaration {
                    name: "x".to_string(),
                    type_annotation: Type::Number,
                    initializer: Expression::Number(1.),
                },
                Statement::Assignment {
                    name: "x".into(),
                    value: Expression::Number(2.),
                },
            ],
        };

        assert_eq!(expected, ast);
    }
}


// ===== End of src/parser.rs =====

// ===== File: src/runtime.rs =====

use std::{cell::RefCell, collections::HashMap, rc::Rc};

use crate::{
    ast::{BinaryOperator, Expression, Program, Statement, UnaryOperator},
    heap::Heap,
    object::{Function, HeapObject, Object},
    value::Value,
};

#[derive(Debug, Clone, PartialEq)]
pub struct Environment {
    pub scopes: Vec<Rc<RefCell<HashMap<String, Value>>>>,
}

impl Environment {
    pub fn new() -> Self {
        Self {
            scopes: vec![Rc::new(RefCell::new(HashMap::new()))], // Start with global scope
        }
    }

    pub fn push_scope(&mut self) {
        self.scopes.push(Rc::new(RefCell::new(HashMap::new())));
    }

    pub fn pop_scope(&mut self) {
        if self.scopes.len() > 1 {
            self.scopes.pop();
        }
    }

    pub fn define(&mut self, name: String, value: Value) {
        if let Some(current_scope) = self.scopes.last_mut() {
            current_scope.borrow_mut().insert(name, value);
        }
    }

    pub fn get(&self, name: &str) -> Result<Value, String> {
        for scope in self.scopes.iter().rev() {
            if let Some(value) = scope.borrow().get(name) {
                return Ok(value.clone());
            }
        }
        Err(format!("Undefined variable '{}'", name))
    }

    pub fn assign(&mut self, name: &str, value: Value) -> Result<Option<Value>, String> {
        for scope in self.scopes.iter().rev() {
            if scope.borrow().contains_key(name) {
                scope.borrow_mut().insert(name.to_string(), value);
                return Ok(None);
            }
        }
        Err(format!("Undefined variable '{}'", name))
    }
}

pub struct Interpreter {
    environment: Environment,
    heap: Heap,
}

impl Interpreter {
    pub fn new() -> Self {
        Self {
            environment: Environment::new(),
            heap: Heap::new(1024),
        }
    }

    pub fn interpret(&mut self, program: &Program) -> Result<(), String> {
        for statement in &program.statements {
            self.execute_statement(statement)?;
        }
        Ok(())
    }

    fn allocate_object(&mut self, object: Object) -> Rc<RefCell<HeapObject>> {
        self.heap.allocate(object)
    }

    fn execute_statement(&mut self, stmt: &Statement) -> Result<Option<Value>, String> {
        match stmt {
            Statement::ExpressionStatement(expr) => {
                // Evaluate the expression but discard the result
                self.evaluate_expression(expr)?;
                Ok(None)
            }
            Statement::VarDeclaration {
                name, initializer, ..
            } => {
                let value = self.evaluate_expression(initializer)?;
                self.environment.define(name.clone(), value);
                Ok(None)
            }
            Statement::Assignment { name, value } => {
                let val = self.evaluate_expression(value)?;
                self.environment.assign(name, val)
            }
            Statement::Print(expr) => {
                let value = self.evaluate_expression(expr)?;
                println!("{}", self.value_to_string(&value));
                Ok(None)
            }
            Statement::If {
                condition,
                then_branch,
                else_branch,
            } => {
                let condition_value = self.evaluate_expression(condition)?;
                let should_execute = match condition_value {
                    Value::Bool(b) => b,
                    _ => return Err("If condition must be boolean".to_string()),
                };

                let mut result: Option<Value> = None;

                if should_execute {
                    result = self.execute_statement(then_branch)?;
                } else if let Some(else_stmt) = else_branch {
                    result = self.execute_statement(else_stmt)?;
                }
                Ok(result)
            }
            Statement::Block(statements) => {
                for stmt in statements {
                    let result = self.execute_statement(stmt)?;
                    if let Some(v) = result {
                        return Ok(Some(v));
                    }
                }
                Ok(None)
            }
            Statement::While { condition, body } => {
                loop {
                    let condition_value = self.evaluate_expression(condition)?;
                    let should_continue = match condition_value {
                        Value::Bool(b) => b,
                        _ => return Err("While condition must be boolean".to_string()),
                    };

                    if !should_continue {
                        break;
                    }

                    self.execute_statement(body)?;
                }
                Ok(None)
            }
            Statement::FunctionDeclaration {
                name,
                parameters,
                return_type,
                body,
            } => {
                let function_obj = Object::Function(Function {
                    name: name.clone(),
                    parameters: parameters.clone(),
                    return_type: return_type.clone(),
                    body: *body.clone(),
                    closure_env: Rc::new(RefCell::new(self.environment.clone())), // Capture current environment
                });

                let heap_obj = self.allocate_object(function_obj);
                self.environment
                    .define(name.clone(), Value::Object(heap_obj));

                Ok(None)
            }
            Statement::Return(expr_opt) => {
                let return_value = match expr_opt {
                    Some(expr) => self.evaluate_expression(expr)?,
                    None => Value::Nil,
                };

                Ok(Some(return_value)) // Use Some to indicate early return
            }
        }
    }

    fn evaluate_expression(&mut self, expr: &Expression) -> Result<Value, String> {
        match expr {
            Expression::Number(n) => Ok(Value::Number(*n)),
            Expression::Bool(b) => Ok(Value::Bool(*b)),
            Expression::String(s) => Ok(Value::String(s.clone())),
            Expression::Nil => Ok(Value::Nil),
            Expression::Identifier(name) => self.environment.get(name),
            Expression::Unary { operator, operand } => {
                let val = self.evaluate_expression(operand)?;
                self.evaluate_unary(operator, val)
            }
            Expression::Binary {
                left,
                operator,
                right,
            } => {
                let left_val = self.evaluate_expression(left)?;
                let right_val = self.evaluate_expression(right)?;
                self.evaluate_binary(&left_val, operator, &right_val)
            }
            Expression::Call { name, arguments } => {
                let function_value = self.environment.get(name)?;

                let function = match function_value {
                    Value::Object(obj) => {
                        let obj_borrow = obj.borrow();
                        match &obj_borrow.object {
                            Object::Function(Function {
                                parameters,
                                body,
                                closure_env,
                                ..
                            }) => (parameters.clone(), body.clone(), closure_env.clone()),
                            _ => return Err(format!("'{}' is not a function", name)),
                        }
                    }
                    _ => return Err(format!("'{}' is not a function", name)),
                };

                let (parameters, body, closure_env) = function;

                if arguments.len() != parameters.len() {
                    return Err(format!(
                        "Function '{}' expects {} arguments, got {}",
                        name,
                        parameters.len(),
                        arguments.len()
                    ));
                }

                // Create new environment starting with closure environment
                let mut call_env = (*closure_env.borrow()).clone();
                call_env.push_scope();

                // Evaluate arguments and bind to parameters
                for (i, p) in parameters.iter().enumerate() {
                    let arg_value = self.evaluate_expression(&arguments[i])?;
                    call_env.define(p.name.clone(), arg_value);
                }

                // Save current environment and switch to call environment
                let saved_env = std::mem::replace(&mut self.environment, call_env);

                // Execute function body
                let result = self.execute_statement(&body);

                // Restore environment
                self.environment = saved_env;

                match result {
                    Ok(Some(return_value)) => Ok(return_value), // Function returned a value
                    Ok(None) => Ok(Value::Nil),                 // Function completed without return
                    Err(e) => Err(e),
                }
            }
        }
    }

    fn evaluate_unary(&self, operator: &UnaryOperator, operand: Value) -> Result<Value, String> {
        match operator {
            UnaryOperator::Not => match operand {
                Value::Bool(b) => Ok(Value::Bool(!b)),
                _ => Err("Cannot apply '!' to non-boolean value".to_string()),
            },
            UnaryOperator::Negate => match operand {
                Value::Number(n) => Ok(Value::Number(-n)),
                _ => Err("Cannot negate non-number value".to_string()),
            },
        }
    }

    fn evaluate_binary(
        &self,
        left: &Value,
        operator: &BinaryOperator,
        right: &Value,
    ) -> Result<Value, String> {
        match operator {
            // Arithmetic operators
            BinaryOperator::Add => match (left, right) {
                (Value::Number(l), Value::Number(r)) => Ok(Value::Number(l + r)),
                (Value::String(l), Value::String(r)) => Ok(Value::String(format!("{}{}", l, r))),
                _ => Err("Cannot add incompatible types".to_string()),
            },
            BinaryOperator::Subtract => match (left, right) {
                (Value::Number(l), Value::Number(r)) => Ok(Value::Number(l - r)),
                _ => Err("Cannot subtract non-number values".to_string()),
            },
            BinaryOperator::Multiply => match (left, right) {
                (Value::Number(l), Value::Number(r)) => Ok(Value::Number(l * r)),
                _ => Err("Cannot multiply non-number values".to_string()),
            },
            BinaryOperator::Divide => match (left, right) {
                (Value::Number(l), Value::Number(r)) => {
                    if *r == 0.0 {
                        Err("Division by zero".to_string())
                    } else {
                        Ok(Value::Number(l / r))
                    }
                }
                _ => Err("Cannot divide non-number values".to_string()),
            },

            // Comparison operators
            BinaryOperator::Less => match (left, right) {
                (Value::Number(l), Value::Number(r)) => Ok(Value::Bool(l < r)),
                _ => Err("Cannot compare non-number values with <".to_string()),
            },
            BinaryOperator::LessEqual => match (left, right) {
                (Value::Number(l), Value::Number(r)) => Ok(Value::Bool(l <= r)),
                _ => Err("Cannot compare non-number values with <=".to_string()),
            },
            BinaryOperator::Greater => match (left, right) {
                (Value::Number(l), Value::Number(r)) => Ok(Value::Bool(l > r)),
                _ => Err("Cannot compare non-number values with >".to_string()),
            },
            BinaryOperator::GreaterEqual => match (left, right) {
                (Value::Number(l), Value::Number(r)) => Ok(Value::Bool(l >= r)),
                _ => Err("Cannot compare non-number values with >=".to_string()),
            },

            // Equality operators
            BinaryOperator::Equal => Ok(Value::Bool(self.values_equal(left, right))),
            BinaryOperator::NotEqual => Ok(Value::Bool(!self.values_equal(left, right))),

            // Logical operators - require explicit booleans
            BinaryOperator::LogicalAnd => match (left, right) {
                (Value::Bool(l), Value::Bool(r)) => Ok(Value::Bool(*l && *r)),
                _ => Err("Logical 'and' requires boolean operands".to_string()),
            },
            BinaryOperator::LogicalOr => match (left, right) {
                (Value::Bool(l), Value::Bool(r)) => Ok(Value::Bool(*l || *r)),
                _ => Err("Logical 'or' requires boolean operands".to_string()),
            },
        }
    }

    // Helper methods
    fn values_equal(&self, left: &Value, right: &Value) -> bool {
        match (left, right) {
            (Value::Number(l), Value::Number(r)) => l == r,
            (Value::Bool(l), Value::Bool(r)) => l == r,
            (Value::String(l), Value::String(r)) => l == r,
            (Value::Nil, Value::Nil) => true,
            _ => false,
        }
    }

    fn value_to_string(&self, value: &Value) -> String {
        match value {
            Value::Number(n) => n.to_string(),
            Value::Bool(b) => b.to_string(),
            Value::String(s) => s.clone(),
            Value::Nil => "nil".to_string(),
            _ => "object".into(),
        }
    }
}


// ===== End of src/runtime.rs =====

// ===== File: src/tokens.rs =====

use crate::{error_handling::Span, keywords::Keyword};

#[derive(Debug, Clone, PartialEq)]
pub enum TokenKind {
    Number(String),
    String(String),
    Identifier(String),
    Keyword(Keyword),
    Operator(Operator),
    Delimiter(Delimiter),
    Special(Special),
}

impl TokenKind {
    pub fn is_keyword(&self, expected: Keyword) -> bool {
        match self {
            TokenKind::Keyword(self_kw) => *self_kw == expected,
            _ => false,
        }
    }

    pub fn is_operator(&self, expected: Operator) -> bool {
        match self {
            TokenKind::Operator(self_op) => *self_op == expected,
            _ => false,
        }
    }

    pub fn is_delimiter(&self, expected: Delimiter) -> bool {
        match self {
            TokenKind::Delimiter(self_delimiter) => *self_delimiter == expected,
            _ => false,
        }
    }

    pub fn is_special(&self, expected: Special) -> bool {
        match self {
            TokenKind::Special(self_kind) => *self_kind == expected,
            _ => false,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Operator {
    Plus,
    PlusEqual,
    Minus,
    MinusEqual,
    Star,
    StarEqual,
    Slash,
    SlashEqual,
    Equal,
    EqualEqual,
    Bang,
    BangEqual,
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Dot,
    Arrow,
    FatArrow,
    Question,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Delimiter {
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    LeftBracket,
    RightBracket,
    Colon,
    Semicolon,
    Comma,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Special {
    Eof,
    Error(String),
}

#[derive(Debug, Clone)]
pub struct Token {
    pub kind: TokenKind,
    pub span: Span,
}

impl Token {
    pub fn new(kind: TokenKind, span: Span) -> Self {
        Self { kind, span }
    }
}


// ===== End of src/tokens.rs =====

// ===== File: src/types.rs =====

use lazy_static::lazy_static;
use std::collections::HashMap;
use std::sync::RwLock;

use crate::ast::Program;

lazy_static! {
    static ref CLASS_REGISTRY: RwLock<HashMap<String, ClassInfo>> = RwLock::new(HashMap::new());
}

use crate::ast::{BinaryOperator, Expression, Statement, UnaryOperator};

#[derive(Debug, Clone)]
pub struct TypeEnvironment {
    scopes: Vec<HashMap<String, Type>>,
}

impl TypeEnvironment {
    pub fn new() -> Self {
        Self {
            scopes: vec![HashMap::new()],
        }
    }

    pub fn push_scope(&mut self) {
        self.scopes.push(HashMap::new());
    }

    pub fn pop_scope(&mut self) {
        if self.scopes.len() > 1 {
            self.scopes.pop();
        }
    }

    pub fn define(&mut self, name: String, type_: Type) {
        if let Some(current_scope) = self.scopes.last_mut() {
            current_scope.insert(name, type_);
        }
    }

    pub fn get(&self, name: &str) -> Result<Type, String> {
        for scope in self.scopes.iter().rev() {
            if let Some(type_) = scope.get(name) {
                return Ok(type_.clone());
            }
        }
        Err(format!("Undefined variable '{}'", name))
    }
}

pub fn type_check_program(program: &Program) -> Result<(), String> {
    let mut type_env = TypeEnvironment::new();

    for statement in &program.statements {
        type_check_statement(statement, &mut type_env, None)?;
    }
    Ok(())
}

fn type_check_statement(
    stmt: &Statement,
    env: &mut TypeEnvironment,
    function_return_type: Option<&Type>,
) -> Result<(), String> {
    match stmt {
        Statement::VarDeclaration {
            name,
            type_annotation,
            initializer,
        } => {
            let init_type = type_check_expression(initializer, env)?;
            if !init_type.is_assignable_to(type_annotation) {
                return Err(format!(
                    "Cannot assign {} to variable '{}' of type {}",
                    type_to_string(&init_type),
                    name,
                    type_to_string(type_annotation)
                ));
            }
            env.define(name.clone(), type_annotation.clone());
            Ok(())
        }
        Statement::Assignment { name, value } => {
            let var_type = env.get(name)?;
            let value_type = type_check_expression(value, env)?;
            if !value_type.is_assignable_to(&var_type) {
                return Err(format!(
                    "Cannot assign {} to variable '{}' of type {}",
                    type_to_string(&value_type),
                    name,
                    type_to_string(&var_type)
                ));
            }
            Ok(())
        }
        Statement::ExpressionStatement(expr) => {
            type_check_expression(expr, env)?;
            Ok(())
        }
        Statement::Print(expr) => {
            type_check_expression(expr, env)?;
            Ok(())
        }
        Statement::If {
            condition,
            then_branch,
            else_branch,
        } => {
            let condition_type = type_check_expression(condition, env)?;
            if condition_type != Type::Bool {
                return Err(format!(
                    "If condition must be boolean, got {}",
                    type_to_string(&condition_type)
                ));
            }

            type_check_statement(then_branch, env, function_return_type)?;
            if let Some(else_stmt) = else_branch {
                type_check_statement(else_stmt, env, function_return_type)?;
            }
            Ok(())
        }
        Statement::While { condition, body } => {
            let condition_type = type_check_expression(condition, env)?;
            if condition_type != Type::Bool {
                return Err(format!(
                    "While condition must be boolean, got {}",
                    type_to_string(&condition_type)
                ));
            }
            type_check_statement(body, env, function_return_type)?;
            Ok(())
        }
        Statement::Block(statements) => {
            for stmt in statements {
                type_check_statement(stmt, env, function_return_type)?;
            }
            Ok(())
        }
        Statement::FunctionDeclaration {
            name,
            parameters,
            return_type,
            body,
        } => {
            let func_type = Type::Function {
                params: parameters
                    .iter()
                    .map(|p| Box::new(p.param_type.clone()))
                    .collect(),
                return_types: match return_type {
                    Some(t) => vec![Box::new(t.clone())],
                    None => vec![],
                },
            };
            env.define(name.clone(), func_type);

            env.push_scope();
            for p in parameters {
                env.define(p.name.clone(), p.param_type.clone());
            }
            type_check_statement(body, env, return_type.as_ref())?; // Pass return type context
            env.pop_scope();

            Ok(())
        }
        Statement::Return(expr_opt) => {
            match (expr_opt, function_return_type) {
                (Some(expr), Some(expected_type)) => {
                    let return_type = type_check_expression(expr, env)?;
                    if !return_type.is_assignable_to(expected_type) {
                        return Err(format!(
                            "Return type {} doesn't match function return type {}",
                            type_to_string(&return_type),
                            type_to_string(expected_type)
                        ));
                    }
                }
                (Some(_), None) => {
                    return Err("Cannot return value from void function".to_string());
                }
                (None, Some(_)) => {
                    return Err("Function must return a value".to_string());
                }
                (None, None) => {
                    // Void return from void function - OK
                }
            }
            Ok(())
        }
    }
}

fn type_check_expression(expr: &Expression, env: &TypeEnvironment) -> Result<Type, String> {
    match expr {
        Expression::Number(_) => Ok(Type::Number),
        Expression::Bool(_) => Ok(Type::Bool),
        Expression::String(_) => Ok(Type::String),
        Expression::Nil => Ok(Type::Nil),
        Expression::Identifier(name) => env.get(name),
        Expression::Unary { operator, operand } => {
            let operand_type = type_check_expression(operand, env)?;
            match operator {
                UnaryOperator::Not => {
                    if operand_type == Type::Bool {
                        Ok(Type::Bool)
                    } else {
                        Err(format!(
                            "Cannot apply '!' to {}",
                            type_to_string(&operand_type)
                        ))
                    }
                }
                UnaryOperator::Negate => {
                    if operand_type == Type::Number {
                        Ok(Type::Number)
                    } else {
                        Err(format!("Cannot negate {}", type_to_string(&operand_type)))
                    }
                }
            }
        }
        Expression::Binary {
            left,
            operator,
            right,
        } => {
            let left_type = type_check_expression(left, env)?;
            let right_type = type_check_expression(right, env)?;

            match operator {
                BinaryOperator::Add => {
                    if left_type == Type::Number && right_type == Type::Number {
                        Ok(Type::Number)
                    } else if left_type == Type::String && right_type == Type::String {
                        Ok(Type::String)
                    } else {
                        Err(format!(
                            "Cannot add {} and {}",
                            type_to_string(&left_type),
                            type_to_string(&right_type)
                        ))
                    }
                }
                BinaryOperator::Subtract | BinaryOperator::Multiply | BinaryOperator::Divide => {
                    if left_type == Type::Number && right_type == Type::Number {
                        Ok(Type::Number)
                    } else {
                        Err(format!(
                            "Cannot apply {:?} to {} and {}",
                            operator,
                            type_to_string(&left_type),
                            type_to_string(&right_type)
                        ))
                    }
                }
                BinaryOperator::Less
                | BinaryOperator::LessEqual
                | BinaryOperator::Greater
                | BinaryOperator::GreaterEqual => {
                    if left_type == Type::Number && right_type == Type::Number {
                        Ok(Type::Bool)
                    } else {
                        Err(format!(
                            "Cannot compare {} and {} with {:?}",
                            type_to_string(&left_type),
                            type_to_string(&right_type),
                            operator
                        ))
                    }
                }
                BinaryOperator::Equal | BinaryOperator::NotEqual => {
                    // Allow equality comparison between same types
                    if left_type == right_type {
                        Ok(Type::Bool)
                    } else {
                        Err(format!(
                            "Cannot compare {} and {} for equality",
                            type_to_string(&left_type),
                            type_to_string(&right_type)
                        ))
                    }
                }
                BinaryOperator::LogicalAnd | BinaryOperator::LogicalOr => {
                    if left_type == Type::Bool && right_type == Type::Bool {
                        Ok(Type::Bool)
                    } else {
                        Err(format!(
                            "Logical {:?} requires boolean operands, got {} and {}",
                            operator,
                            type_to_string(&left_type),
                            type_to_string(&right_type)
                        ))
                    }
                }
            }
        }
        Expression::Call { name, arguments } => {
            let func_type = env.get(name)?;
            if let Type::Function {
                params,
                return_types,
            } = func_type
            {
                if arguments.len() != params.len() {
                    return Err(format!(
                        "Function '{}' expects {} arguments, got {}",
                        name,
                        params.len(),
                        arguments.len()
                    ));
                }

                for (i, arg) in arguments.iter().enumerate() {
                    let arg_type = type_check_expression(arg, env)?;
                    if !arg_type.is_assignable_to(&params[i]) {
                        return Err(format!("Argument {} type mismatch", i));
                    }
                }

                if return_types.len() == 1 {
                    Ok((*return_types[0]).clone())
                } else {
                    Ok(Type::Nil) // Void function
                }
            } else {
                Err(format!("'{}' is not a function", name))
            }
        }
    }
}

fn type_to_string(type_: &Type) -> String {
    match type_ {
        Type::Number => "Number".to_string(),
        Type::Bool => "Bool".to_string(),
        Type::String => "String".to_string(),
        Type::Nil => "Nil".to_string(),
        Type::Class(name) => name.clone(),
        Type::Nullable(inner) => format!("{}?", type_to_string(inner)),
        _ => format!("{:?}", type_), // For complex types not yet implemented
    }
}

struct ClassInfo {
    _name: String,
    superclass: Option<String>,
}

impl ClassInfo {
    fn is_subtype_of(&self, parent: &str) -> bool {
        let mut current = self.superclass.clone();

        while let Some(super_name) = current {
            if super_name == parent {
                return true;
            }
            current = CLASS_REGISTRY
                .read()
                .unwrap()
                .get(&super_name)
                .and_then(|ci| ci.superclass.clone());
        }

        false
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Number,
    Bool,
    String,
    Nil,
    Tuple(Vec<Box<Type>>),
    NamedTuple(Vec<(String, Box<Type>)>),
    Function {
        params: Vec<Box<Type>>,
        return_types: Vec<Box<Type>>,
    },
    // User-defined types.
    Class(String), // String is the fully-qualified class name.
    // Nullable Wrapper
    Nullable(Box<Type>),
}

impl Type {
    fn is_nullable(&self) -> bool {
        if let Type::Nullable(_) = self {
            return true;
        }

        false
    }

    /// Check if this type is assignable to another type.
    pub fn is_assignable_to(&self, other: &Type) -> bool {
        match (self, other) {
            (Type::Tuple(elements_1), Type::Tuple(elements_2)) => {
                elements_1.len() == elements_2.len()
                    && elements_1
                        .iter()
                        .zip(elements_2.iter())
                        .all(|(el_1_type, el_2_type)| el_1_type.is_assignable_to(el_2_type))
            }
            (Type::NamedTuple(elements_1), Type::NamedTuple(elements_2)) => {
                elements_1.len() == elements_2.len()
                    && elements_1.iter().zip(elements_2.iter()).all(
                        |((_, el_1_type), (_, el_2_type))| el_1_type.is_assignable_to(el_2_type),
                    )
            }
            (Type::NamedTuple(named_elements), Type::Tuple(elements)) => {
                named_elements.len() == elements.len()
                    && named_elements.iter().zip(elements.iter()).all(
                        |((_, named_element_type), element_type)| {
                            named_element_type.is_assignable_to(element_type)
                        },
                    )
            }

            (Type::Tuple(elements), Type::NamedTuple(named_elements)) => {
                elements.len() == named_elements.len()
                    && elements.iter().zip(named_elements.iter()).all(
                        |(element_type, (_, named_element_type))| {
                            element_type.is_assignable_to(named_element_type)
                        },
                    )
            }
            (
                Type::Function {
                    params: params1,
                    return_types: returns1,
                },
                Type::Function {
                    params: params2,
                    return_types: returns2,
                },
            ) => {
                // Same number of parameters and return values
                if params1.len() != params2.len() || returns1.len() != returns2.len() {
                    return false;
                }

                // Parameters are contravariant: self param type must be a supertype of other param type
                let params_ok = params1
                    .iter()
                    .zip(params2.iter())
                    .all(|(self_param, other_param)| other_param.is_assignable_to(self_param));

                // Return types are covariant: self return type must be a subtype of other return type
                let returns_ok = returns1
                    .iter()
                    .zip(returns2.iter())
                    .all(|(self_ret, other_ret)| self_ret.is_assignable_to(other_ret));

                params_ok && returns_ok
            }

            (Type::Class(a_name), Type::Class(b_name)) => {
                if a_name == b_name {
                    true
                } else {
                    CLASS_REGISTRY
                        .read()
                        .unwrap()
                        .get(a_name)
                        .map_or(false, |class_info| class_info.is_subtype_of(b_name))
                }
            }

            // nil can be assigned to any nullable type
            (Type::Nil, Type::Nullable(_)) => true,

            (Type::Nullable(a), b) if !b.is_nullable() => {
                println!("a {:#?}, b {:#?}", a, b);
                false
            }
            (Type::Nullable(a), Type::Nullable(b)) => a.is_assignable_to(b),

            // Allow non-null assignment to nullable of same type.
            (a, Type::Nullable(nullable_inner)) => a.is_assignable_to(&nullable_inner),

            (a, b) if a == b => true,

            // Nothing else is assignable.
            _ => false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exact_type_matches() {
        // Built-in types should match themselves
        assert!(Type::Number.is_assignable_to(&Type::Number));
        assert!(Type::Bool.is_assignable_to(&Type::Bool));
        assert!(Type::String.is_assignable_to(&Type::String));
        assert!(Type::Nil.is_assignable_to(&Type::Nil));

        // Class types should match themselves
        let point = Type::Class("Point".to_string());
        assert!(point.is_assignable_to(&point));

        // Different classes should not match
        let point = Type::Class("Point".to_string());
        let rectangle = Type::Class("Rectangle".to_string());
        assert!(!point.is_assignable_to(&rectangle));
    }

    #[test]
    fn test_nil_to_nullable_assignment() {
        // nil can be assigned to any nullable type
        assert!(Type::Nil.is_assignable_to(&Type::Nullable(Box::new(Type::Number))));
        assert!(Type::Nil.is_assignable_to(&Type::Nullable(Box::new(Type::String))));
        assert!(Type::Nil.is_assignable_to(&Type::Nullable(Box::new(Type::Bool))));

        // nil can be assigned to nullable class types
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        assert!(Type::Nil.is_assignable_to(&nullable_point));

        // nil cannot be assigned to non-nullable types
        assert!(!Type::Nil.is_assignable_to(&Type::Number));
        assert!(!Type::Nil.is_assignable_to(&Type::String));
        assert!(!Type::Nil.is_assignable_to(&Type::Class("Point".to_string())));
    }

    #[test]
    fn test_non_null_to_nullable_assignment() {
        // Built-in types can be assigned to their nullable versions
        assert!(Type::Number.is_assignable_to(&Type::Nullable(Box::new(Type::Number))));
        assert!(Type::String.is_assignable_to(&Type::Nullable(Box::new(Type::String))));
        assert!(Type::Bool.is_assignable_to(&Type::Nullable(Box::new(Type::Bool))));

        // Class types can be assigned to their nullable versions
        let point = Type::Class("Point".to_string());
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        assert!(point.is_assignable_to(&nullable_point));

        // Wrong types cannot be assigned to nullable of different type
        assert!(!Type::Number.is_assignable_to(&Type::Nullable(Box::new(Type::String))));
        assert!(!Type::String.is_assignable_to(&Type::Nullable(Box::new(Type::Number))));
    }

    #[test]
    fn test_nullable_cannot_be_assigned_to_non_nullable() {
        // Nullable types cannot be assigned to non-nullable versions
        let nullable_int = Type::Nullable(Box::new(Type::Number));
        assert!(!nullable_int.is_assignable_to(&Type::Number));

        let nullable_string = Type::Nullable(Box::new(Type::String));
        assert!(!nullable_string.is_assignable_to(&Type::String));

        // Nullable classes cannot be assigned to non-nullable classes
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        let point = Type::Class("Point".to_string());
        assert!(!nullable_point.is_assignable_to(&point));
    }

    #[test]
    fn test_nullable_type_equality() {
        // Nullable types should be equal to themselves
        let nullable_int = Type::Nullable(Box::new(Type::Number));
        let another_nullable_int = Type::Nullable(Box::new(Type::Number));
        assert!(nullable_int.is_assignable_to(&another_nullable_int));

        // Different nullable types should not be equal
        let nullable_int = Type::Nullable(Box::new(Type::Number));
        let nullable_string = Type::Nullable(Box::new(Type::String));
        assert!(!nullable_int.is_assignable_to(&nullable_string));

        // Nullable class types
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        let another_nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));
        assert!(nullable_point.is_assignable_to(&another_nullable_point));
    }

    #[test]
    fn test_incompatible_type_assignments() {
        // Built-in types cannot be assigned to each other
        assert!(!Type::Number.is_assignable_to(&Type::String));
        assert!(!Type::Bool.is_assignable_to(&Type::Number));
        assert!(!Type::String.is_assignable_to(&Type::Bool));

        // Classes cannot be assigned to built-in types
        let point = Type::Class("Point".to_string());
        assert!(!point.is_assignable_to(&Type::Number));
        assert!(!point.is_assignable_to(&Type::String));
        assert!(!Type::String.is_assignable_to(&point));

        // Different classes cannot be assigned to each other
        let point = Type::Class("Point".to_string());
        let rectangle = Type::Class("Rectangle".to_string());
        assert!(!point.is_assignable_to(&rectangle));
        assert!(!rectangle.is_assignable_to(&point));
    }

    #[test]
    fn test_fully_qualified_class_names() {
        // Different fully-qualified names should be different types
        let local_point = Type::Class("Point".to_string());
        let graphics_point = Type::Class("graphics.Point".to_string());
        let math_point = Type::Class("math.Point".to_string());

        assert!(!local_point.is_assignable_to(&graphics_point));
        assert!(!graphics_point.is_assignable_to(&math_point));
        assert!(!math_point.is_assignable_to(&local_point));

        // But same fully-qualified names should match
        let point1 = Type::Class("graphics.Point".to_string());
        let point2 = Type::Class("graphics.Point".to_string());
        assert!(point1.is_assignable_to(&point2));
    }

    #[test]
    fn test_nullable_class_types() {
        let point = Type::Class("Point".to_string());
        let nullable_point = Type::Nullable(Box::new(Type::Class("Point".to_string())));

        // Point can be assigned to Point?
        assert!(point.is_assignable_to(&nullable_point));

        // Point? cannot be assigned to Point
        assert!(!nullable_point.is_assignable_to(&point));

        // nil can be assigned to Point?
        assert!(Type::Nil.is_assignable_to(&nullable_point));
    }

    #[test]
    fn test_tuple_types() {
        // Empty tuple (unit type)
        let unit = Type::Tuple(vec![]);
        assert!(unit.is_assignable_to(&unit));

        // Simple tuple
        let int_string_tuple = Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);

        // Same tuple structure should match
        let another_int_string_tuple =
            Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);
        assert!(int_string_tuple.is_assignable_to(&another_int_string_tuple));

        // Different tuple structures should not match
        let string_int_tuple = Type::Tuple(vec![Box::new(Type::String), Box::new(Type::Number)]);
        assert!(!int_string_tuple.is_assignable_to(&string_int_tuple));
    }

    #[test]
    fn test_named_tuple_types() {
        // Named tuple for function return
        let divide_result = Type::NamedTuple(vec![
            ("result".to_string(), Box::new(Type::Number)),
            (
                "error".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
        ]);

        // Same named tuple should match
        let another_divide_result = Type::NamedTuple(vec![
            ("result".to_string(), Box::new(Type::Number)),
            (
                "error".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
        ]);
        assert!(divide_result.is_assignable_to(&another_divide_result));

        // Different field names should not match
        let different_names = Type::NamedTuple(vec![
            ("value".to_string(), Box::new(Type::Number)),
            (
                "message".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
        ]);
        assert!(divide_result.is_assignable_to(&different_names));

        // Different field order should not match
        let different_order = Type::NamedTuple(vec![
            (
                "error".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
            ("result".to_string(), Box::new(Type::Number)),
        ]);
        assert!(!divide_result.is_assignable_to(&different_order));
    }

    #[test]
    fn test_function_types() {
        // Simple function: (Number, Number) -> Number
        let add_function = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Number)],
        };

        // Same function signature should match
        let another_add_function = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Number)],
        };
        assert!(add_function.is_assignable_to(&another_add_function));

        // Different return types should not match
        let string_function = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        };
        assert!(!add_function.is_assignable_to(&string_function));

        // Multiple return values
        let multi_return_function = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Number), Box::new(Type::String)],
        };

        // Different number of return values should not match
        assert!(!add_function.is_assignable_to(&multi_return_function));
    }

    #[test]
    fn test_nullable_complex_types() {
        // Nullable tuple
        let nullable_tuple = Type::Nullable(Box::new(Type::Tuple(vec![
            Box::new(Type::Number),
            Box::new(Type::String),
        ])));

        // Regular tuple can be assigned to nullable tuple
        let regular_tuple = Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);
        assert!(regular_tuple.is_assignable_to(&nullable_tuple));

        // nil can be assigned to nullable tuple
        assert!(Type::Nil.is_assignable_to(&nullable_tuple));

        // Nullable function
        let nullable_function = Type::Nullable(Box::new(Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        }));

        let regular_function = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        };
        assert!(regular_function.is_assignable_to(&nullable_function));
        assert!(Type::Nil.is_assignable_to(&nullable_function));

        // Nullable named tuple
        let nullable_named_tuple = Type::Nullable(Box::new(Type::NamedTuple(vec![(
            "result".to_string(),
            Box::new(Type::Number),
        )])));

        let regular_named_tuple =
            Type::NamedTuple(vec![("result".to_string(), Box::new(Type::Number))]);
        assert!(regular_named_tuple.is_assignable_to(&nullable_named_tuple));
        assert!(Type::Nil.is_assignable_to(&nullable_named_tuple));
    }

    #[test]
    fn test_tuple_named_tuple_interchangeability() {
        // Plain tuple and named tuple with same structure should be interchangeable
        let plain_tuple = Type::Tuple(vec![
            Box::new(Type::Number),
            Box::new(Type::String),
            Box::new(Type::Bool),
        ]);

        let named_tuple = Type::NamedTuple(vec![
            ("first".to_string(), Box::new(Type::Number)),
            ("second".to_string(), Box::new(Type::String)),
            ("third".to_string(), Box::new(Type::Bool)),
        ]);

        // Both directions should work
        assert!(plain_tuple.is_assignable_to(&named_tuple));
        assert!(named_tuple.is_assignable_to(&plain_tuple));

        // Different lengths should not be assignable
        let shorter_plain = Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);
        assert!(!plain_tuple.is_assignable_to(&shorter_plain));
        assert!(!named_tuple.is_assignable_to(&shorter_plain));
    }

    #[test]
    fn test_tuple_assignability_with_nullable() {
        // Tuple with non-nullable element
        let plain_tuple = Type::Tuple(vec![Box::new(Type::Number), Box::new(Type::String)]);

        // Tuple with nullable element
        let nullable_tuple = Type::Tuple(vec![
            Box::new(Type::Number),
            Box::new(Type::Nullable(Box::new(Type::String))),
        ]);

        // Non-nullable tuple should be assignable to nullable tuple
        assert!(plain_tuple.is_assignable_to(&nullable_tuple));

        // Nullable tuple should NOT be assignable to non-nullable tuple
        assert!(!nullable_tuple.is_assignable_to(&plain_tuple));

        // Same test with named tuples
        let plain_named = Type::NamedTuple(vec![
            ("id".to_string(), Box::new(Type::Number)),
            ("name".to_string(), Box::new(Type::String)),
        ]);

        let nullable_named = Type::NamedTuple(vec![
            ("id".to_string(), Box::new(Type::Number)),
            (
                "name".to_string(),
                Box::new(Type::Nullable(Box::new(Type::String))),
            ),
        ]);

        assert!(plain_named.is_assignable_to(&nullable_named));
        assert!(!nullable_named.is_assignable_to(&plain_named));
    }

    #[test]
    fn test_function_assignability_exact_match() {
        // Simple function: (Number, String) -> Bool
        let func1 = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::String)],
            return_types: vec![Box::new(Type::Bool)],
        };

        // Exact same signature
        let func2 = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::String)],
            return_types: vec![Box::new(Type::Bool)],
        };

        // Should be assignable to each other
        assert!(func1.is_assignable_to(&func2));
        assert!(func2.is_assignable_to(&func1));
    }

    #[test]
    fn test_function_assignability_parameter_mismatch() {
        let base_func = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::String)],
            return_types: vec![Box::new(Type::Bool)],
        };

        // Different parameter count
        let fewer_params = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Bool)],
        };
        assert!(!base_func.is_assignable_to(&fewer_params));
        assert!(!fewer_params.is_assignable_to(&base_func));

        // Different parameter types
        let different_param_types = Type::Function {
            params: vec![Box::new(Type::String), Box::new(Type::String)], // Number -> Number
            return_types: vec![Box::new(Type::Bool)],
        };
        assert!(!base_func.is_assignable_to(&different_param_types));
        assert!(!different_param_types.is_assignable_to(&base_func));

        // Different parameter order
        let swapped_params = Type::Function {
            params: vec![Box::new(Type::String), Box::new(Type::Number)], // Swapped order
            return_types: vec![Box::new(Type::Bool)],
        };
        assert!(!base_func.is_assignable_to(&swapped_params));
        assert!(!swapped_params.is_assignable_to(&base_func));
    }

    #[test]
    fn test_function_assignability_return_type_mismatch() {
        let base_func = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        };

        // Different return type
        let different_return = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Bool)], // String -> Bool
        };
        assert!(!base_func.is_assignable_to(&different_return));
        assert!(!different_return.is_assignable_to(&base_func));

        // Different number of return values
        let multiple_returns = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String), Box::new(Type::Bool)],
        };
        assert!(!base_func.is_assignable_to(&multiple_returns));
        assert!(!multiple_returns.is_assignable_to(&base_func));

        // Void function vs non-void
        let void_func = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![],
        };
        assert!(!base_func.is_assignable_to(&void_func));
        assert!(!void_func.is_assignable_to(&base_func));
    }

    #[test]
    fn test_function_assignability_with_tuples() {
        // Function returning plain tuple
        let plain_tuple_func = Type::Function {
            params: vec![],
            return_types: vec![Box::new(Type::Tuple(vec![
                Box::new(Type::Number),
                Box::new(Type::String),
            ]))],
        };

        // Function returning named tuple with same structure
        let named_tuple_func = Type::Function {
            params: vec![],
            return_types: vec![Box::new(Type::NamedTuple(vec![
                ("result".to_string(), Box::new(Type::Number)),
                ("message".to_string(), Box::new(Type::String)),
            ]))],
        };

        // Should be assignable due to tuple/named tuple interchangeability
        assert!(plain_tuple_func.is_assignable_to(&named_tuple_func));
        assert!(named_tuple_func.is_assignable_to(&plain_tuple_func));
    }

    #[test]
    fn test_function_assignability_multiple_return_values() {
        // Function with multiple return values
        let multi_return = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![
                Box::new(Type::Number),
                Box::new(Type::String),
                Box::new(Type::Bool),
            ],
        };

        // Same signature
        let same_multi_return = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![
                Box::new(Type::Number),
                Box::new(Type::String),
                Box::new(Type::Bool),
            ],
        };

        assert!(multi_return.is_assignable_to(&same_multi_return));

        // Different order of return types
        let different_order_returns = Type::Function {
            params: vec![Box::new(Type::Number), Box::new(Type::Number)],
            return_types: vec![
                Box::new(Type::String),
                Box::new(Type::Number),
                Box::new(Type::Bool),
            ],
        };
        assert!(!multi_return.is_assignable_to(&different_order_returns));
    }

    #[test]
    fn test_function_assignability_with_nullable_parameters() {
        // Function with non-nullable parameter
        let non_nullable_param = Type::Function {
            params: vec![Box::new(Type::String)],
            return_types: vec![Box::new(Type::Number)],
        };

        // Function with nullable parameter
        let nullable_param = Type::Function {
            params: vec![Box::new(Type::Nullable(Box::new(Type::String)))],
            return_types: vec![Box::new(Type::Number)],
        };

        // This SHOULD work - more general function can substitute for more specific one
        assert_eq!(true, nullable_param.is_assignable_to(&non_nullable_param));
    }

    #[test]
    fn test_function_assignability_with_nullable_returns() {
        // Function with non-nullable return
        let non_nullable_return = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::String)],
        };

        // Function with nullable return
        let nullable_return = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![Box::new(Type::Nullable(Box::new(Type::String)))],
        };

        assert!(non_nullable_return.is_assignable_to(&nullable_return));
        assert!(!nullable_return.is_assignable_to(&non_nullable_return));
    }

    #[test]
    fn test_void_functions() {
        // Void function (no return values)
        let void_func = Type::Function {
            params: vec![Box::new(Type::String)],
            return_types: vec![],
        };

        // Another void function with same parameters
        let another_void_func = Type::Function {
            params: vec![Box::new(Type::String)],
            return_types: vec![],
        };

        // Should be assignable
        assert!(void_func.is_assignable_to(&another_void_func));

        // Void function with different parameters
        let different_void_func = Type::Function {
            params: vec![Box::new(Type::Number)],
            return_types: vec![],
        };

        assert!(!void_func.is_assignable_to(&different_void_func));
    }

    #[test]
    fn test_complex_nested_function_types() {
        // Function that takes a function as parameter
        let higher_order_func = Type::Function {
            params: vec![Box::new(Type::Function {
                params: vec![Box::new(Type::Number)],
                return_types: vec![Box::new(Type::String)],
            })],
            return_types: vec![Box::new(Type::Bool)],
        };

        // Same higher-order function
        let same_higher_order = Type::Function {
            params: vec![Box::new(Type::Function {
                params: vec![Box::new(Type::Number)],
                return_types: vec![Box::new(Type::String)],
            })],
            return_types: vec![Box::new(Type::Bool)],
        };

        assert!(higher_order_func.is_assignable_to(&same_higher_order));

        // Different inner function signature
        let different_inner = Type::Function {
            params: vec![Box::new(Type::Function {
                params: vec![Box::new(Type::String)],
                return_types: vec![Box::new(Type::String)],
            })],
            return_types: vec![Box::new(Type::Bool)],
        };

        assert!(!higher_order_func.is_assignable_to(&different_inner));
    }

    // Helper to reset registry for each test
    fn setup_registry() {
        let mut registry = CLASS_REGISTRY.write().unwrap();
        registry.clear();

        registry.insert(
            "Animal".to_string(),
            ClassInfo {
                _name: "Animal".to_string(),
                superclass: None,
            },
        );
        registry.insert(
            "Dog".to_string(),
            ClassInfo {
                _name: "Dog".to_string(),
                superclass: Some("Animal".to_string()),
            },
        );
        registry.insert(
            "Cat".to_string(),
            ClassInfo {
                _name: "Cat".to_string(),
                superclass: Some("Animal".to_string()),
            },
        );
        registry.insert(
            "Poodle".to_string(),
            ClassInfo {
                _name: "Poodle".to_string(),
                superclass: Some("Dog".to_string()),
            },
        );
    }

    #[test]
    fn test_class_exact_match() {
        setup_registry();
        let a = Type::Class("Dog".to_string());
        let b = Type::Class("Dog".to_string());

        assert!(a.is_assignable_to(&b));
    }

    #[test]
    fn test_class_subtype() {
        setup_registry();
        let poodle = Type::Class("Poodle".to_string());
        let dog = Type::Class("Dog".to_string());
        let animal = Type::Class("Animal".to_string());

        assert!(poodle.is_assignable_to(&dog));
        assert!(poodle.is_assignable_to(&animal));
    }

    #[test]
    fn test_class_supertype_not_assignable_to_subtype() {
        setup_registry();
        let dog = Type::Class("Dog".to_string());
        let poodle = Type::Class("Poodle".to_string());

        assert!(!dog.is_assignable_to(&poodle));
    }

    #[test]
    fn test_class_unregistered() {
        setup_registry();
        let unknown = Type::Class("Dragon".to_string());
        let animal = Type::Class("Animal".to_string());

        // Unregistered class should not be assignable to anything
        assert!(!unknown.is_assignable_to(&animal));
    }
}


// ===== End of src/types.rs =====

// ===== File: src/value.rs =====

use std::{cell::RefCell, rc::Rc};

use crate::object::HeapObject;

#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Number(f64),
    Bool(bool),
    Nil,
    String(String),
    Object(Rc<RefCell<HeapObject>>),
}


// ===== End of src/value.rs =====

